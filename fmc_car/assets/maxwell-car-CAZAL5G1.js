import{M as st,I as Vi,S as $e,D as ht,R as Ft,V as Q,a as it,A as Wi,b as Ar,Q as Dn,c as Ir,d as Ki,e as kn,f as Cr,H as Le,F as Ae,g as Lt,L as xe,T as tt,h as nt,i as Zi,r as y,u as Ie,W as Dr,C as Xi,k as qi,l as Yi,m as $i,n as Qi,U as z,o as me,N as ot,p as Re,q as nn,s as Ur,B as Ot,t as be,v as zn,w as Hn,P as Ji,x as vn,y as Gn,z as Lr,E as es,G as ts,J as Ye,K as qe,O as Pr,X as jn,Y as gn,Z as ns,_ as Nr,$ as Un,a0 as rs,a1 as is,a2 as ss,a3 as Br,a4 as Be,a5 as mt,a6 as pt,a7 as Tn,a8 as Fr,a9 as fr,aa as Jt,ab as at,ac as as,ad as os,ae as ls,af as cs,ag as Ln,ah as us,j as _,ai as Fe,aj as Ct,ak as kt,al as Se,am as fs,an as ds,ao as hs,ap as ms,aq as ps,ar as xn,as as Vn,at as un,au as Or,av as Wn,aw as en,ax as mn,ay as At,az as vs,aA as gs,aB as xs,aC as Dt,aD as ws,aE as kr,aF as zr,aG as Ts,aH as ys,aI as Pn,aJ as Kn,aK as Ss,aL as _s,aM as Es,aN as Ms,aO as bs,aP as Rs,aQ as Zn,aR as _n,aS as As,aT as Is,aU as Hr,aV as Cs,aW as Gr,aX as Ds,aY as Us,aZ as Ls,a_ as Ps,a$ as Ns,b0 as Bs,b1 as Fs,b2 as Os,b3 as Mt,b4 as ks,b5 as zs,b6 as Hs,b7 as yn,b8 as Gs,b9 as js}from"./index-CWnw20qN.js";import{_ as dt,s as Vs,L as Ws,O as Ks,e as He,u as vt,C as Zs,a as Xs}from"./tween.esm-DlHsekBn.js";let Zt;function qs(){var t;if(Zt!==void 0)return Zt;try{let e;const n=document.createElement("canvas");return Zt=!!(window.WebGL2RenderingContext&&(e=n.getContext("webgl2"))),e&&((t=e.getExtension("WEBGL_lose_context"))==null||t.loseContext()),Zt}catch{return Zt=!1}}var Xe=Uint8Array,_t=Uint16Array,Nn=Uint32Array,jr=new Xe([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Vr=new Xe([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Ys=new Xe([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Wr=function(t,e){for(var n=new _t(31),r=0;r<31;++r)n[r]=e+=1<<t[r-1];for(var i=new Nn(n[30]),r=1;r<30;++r)for(var s=n[r];s<n[r+1];++s)i[s]=s-n[r]<<5|r;return[n,i]},Kr=Wr(jr,2),Zr=Kr[0],$s=Kr[1];Zr[28]=258,$s[258]=28;var Qs=Wr(Vr,0),Js=Qs[0],Bn=new _t(32768);for(var ve=0;ve<32768;++ve){var xt=(ve&43690)>>>1|(ve&21845)<<1;xt=(xt&52428)>>>2|(xt&13107)<<2,xt=(xt&61680)>>>4|(xt&3855)<<4,Bn[ve]=((xt&65280)>>>8|(xt&255)<<8)>>>1}var tn=function(t,e,n){for(var r=t.length,i=0,s=new _t(e);i<r;++i)++s[t[i]-1];var a=new _t(e);for(i=0;i<e;++i)a[i]=a[i-1]+s[i-1]<<1;var o;if(n){o=new _t(1<<e);var l=15-e;for(i=0;i<r;++i)if(t[i])for(var c=i<<4|t[i],d=e-t[i],m=a[t[i]-1]++<<d,f=m|(1<<d)-1;m<=f;++m)o[Bn[m]>>>l]=c}else for(o=new _t(r),i=0;i<r;++i)t[i]&&(o[i]=Bn[a[t[i]-1]++]>>>15-t[i]);return o},sn=new Xe(288);for(var ve=0;ve<144;++ve)sn[ve]=8;for(var ve=144;ve<256;++ve)sn[ve]=9;for(var ve=256;ve<280;++ve)sn[ve]=7;for(var ve=280;ve<288;++ve)sn[ve]=8;var Xr=new Xe(32);for(var ve=0;ve<32;++ve)Xr[ve]=5;var ea=tn(sn,9,1),ta=tn(Xr,5,1),En=function(t){for(var e=t[0],n=1;n<t.length;++n)t[n]>e&&(e=t[n]);return e},et=function(t,e,n){var r=e/8|0;return(t[r]|t[r+1]<<8)>>(e&7)&n},Mn=function(t,e){var n=e/8|0;return(t[n]|t[n+1]<<8|t[n+2]<<16)>>(e&7)},na=function(t){return(t/8|0)+(t&7&&1)},ra=function(t,e,n){(n==null||n>t.length)&&(n=t.length);var r=new(t instanceof _t?_t:t instanceof Nn?Nn:Xe)(n-e);return r.set(t.subarray(e,n)),r},ia=function(t,e,n){var r=t.length;if(!r||n&&!n.l&&r<5)return e||new Xe(0);var i=!e||n,s=!n||n.i;n||(n={}),e||(e=new Xe(r*3));var a=function(ce){var lt=e.length;if(ce>lt){var ct=new Xe(Math.max(lt*2,ce));ct.set(e),e=ct}},o=n.f||0,l=n.p||0,c=n.b||0,d=n.l,m=n.d,f=n.m,p=n.n,T=r*8;do{if(!d){n.f=o=et(t,l,1);var g=et(t,l+1,3);if(l+=3,g)if(g==1)d=ea,m=ta,f=9,p=5;else if(g==2){var A=et(t,l,31)+257,R=et(t,l+10,15)+4,P=A+et(t,l+5,31)+1;l+=14;for(var D=new Xe(P),U=new Xe(19),E=0;E<R;++E)U[Ys[E]]=et(t,l+E*3,7);l+=R*3;for(var C=En(U),j=(1<<C)-1,Y=tn(U,C,1),E=0;E<P;){var X=Y[et(t,l,j)];l+=X&15;var x=X>>>4;if(x<16)D[E++]=x;else{var K=0,G=0;for(x==16?(G=3+et(t,l,3),l+=2,K=D[E-1]):x==17?(G=3+et(t,l,7),l+=3):x==18&&(G=11+et(t,l,127),l+=7);G--;)D[E++]=K}}var Z=D.subarray(0,A),q=D.subarray(A);f=En(Z),p=En(q),d=tn(Z,f,1),m=tn(q,p,1)}else throw"invalid block type";else{var x=na(l)+4,w=t[x-4]|t[x-3]<<8,I=x+w;if(I>r){if(s)throw"unexpected EOF";break}i&&a(c+w),e.set(t.subarray(x,I),c),n.b=c+=w,n.p=l=I*8;continue}if(l>T){if(s)throw"unexpected EOF";break}}i&&a(c+131072);for(var we=(1<<f)-1,Oe=(1<<p)-1,Ce=l;;Ce=l){var K=d[Mn(t,l)&we],ae=K>>>4;if(l+=K&15,l>T){if(s)throw"unexpected EOF";break}if(!K)throw"invalid length/literal";if(ae<256)e[c++]=ae;else if(ae==256){Ce=l,d=null;break}else{var Te=ae-254;if(ae>264){var E=ae-257,ee=jr[E];Te=et(t,l,(1<<ee)-1)+Zr[E],l+=ee}var re=m[Mn(t,l)&Oe],ke=re>>>4;if(!re)throw"invalid distance";l+=re&15;var q=Js[ke];if(ke>3){var ee=Vr[ke];q+=Mn(t,l)&(1<<ee)-1,l+=ee}if(l>T){if(s)throw"unexpected EOF";break}i&&a(c+131072);for(var bt=c+Te;c<bt;c+=4)e[c]=e[c-q],e[c+1]=e[c+1-q],e[c+2]=e[c+2-q],e[c+3]=e[c+3-q];c=bt}}n.l=d,n.p=Ce,n.b=c,d&&(o=1,n.m=f,n.d=m,n.n=p)}while(!o);return c==e.length?e:ra(e,0,c)},sa=new Xe(0),aa=function(t){if((t[0]&15)!=8||t[0]>>>4>7||(t[0]<<8|t[1])%31)throw"invalid zlib data";if(t[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function fn(t,e){return ia((aa(t),t.subarray(2,-4)),e)}var oa=typeof TextDecoder<"u"&&new TextDecoder,la=0;try{oa.decode(sa,{stream:!0}),la=1}catch{}const ca=t=>t&&t.isCubeTexture;class ua extends st{constructor(e,n){var r,i;const s=ca(e),o=((i=s?(r=e.image[0])==null?void 0:r.width:e.image.width)!=null?i:1024)/4,l=Math.floor(Math.log2(o)),c=Math.pow(2,l),d=3*Math.max(c,16*7),m=4*c,f=[s?"#define ENVMAP_TYPE_CUBE":"",`#define CUBEUV_TEXEL_WIDTH ${1/d}`,`#define CUBEUV_TEXEL_HEIGHT ${1/m}`,`#define CUBEUV_MAX_MIP ${l}.0`],p=`
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,T=f.join(`
`)+`
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${parseInt(Ft.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
        }
        `,g={map:{value:e},height:{value:(n==null?void 0:n.height)||15},radius:{value:(n==null?void 0:n.radius)||100}},x=new Vi(1,16),w=new $e({uniforms:g,fragmentShader:T,vertexShader:p,side:ht});super(x,w)}set radius(e){this.material.uniforms.radius.value=e}get radius(){return this.material.uniforms.radius.value}set height(e){this.material.uniforms.height.value=e}get height(){return this.material.uniforms.height.value}}function qr(t,e,n={}){const r=new Q,i=new kn,s=new Q,a=new it,o=new it,l=new it;n.preserveMatrix=n.preserveMatrix!==void 0?n.preserveMatrix:!0,n.preservePosition=n.preservePosition!==void 0?n.preservePosition:!0,n.preserveHipPosition=n.preserveHipPosition!==void 0?n.preserveHipPosition:!1,n.useTargetMatrix=n.useTargetMatrix!==void 0?n.useTargetMatrix:!1,n.hip=n.hip!==void 0?n.hip:"hip",n.names=n.names||{};const c=e.isObject3D?e.skeleton.bones:wn(e),d=t.isObject3D?t.skeleton.bones:wn(t);let m,f,p,T,g;if(t.isObject3D?t.skeleton.pose():(n.useTargetMatrix=!0,n.preserveMatrix=!1),n.preservePosition){g=[];for(let x=0;x<d.length;x++)g.push(d[x].position.clone())}if(n.preserveMatrix){t.updateMatrixWorld(),t.matrixWorld.identity();for(let x=0;x<t.children.length;++x)t.children[x].updateMatrixWorld(!0)}if(n.offsets){m=[];for(let x=0;x<d.length;++x)f=d[x],p=n.names[f.name]||f.name,n.offsets[p]&&(f.matrix.multiply(n.offsets[p]),f.matrix.decompose(f.position,f.quaternion,f.scale),f.updateMatrixWorld()),m.push(f.matrixWorld.clone())}for(let x=0;x<d.length;++x){if(f=d[x],p=n.names[f.name]||f.name,T=Yr(p,c),l.copy(f.matrixWorld),T){if(T.updateMatrixWorld(),n.useTargetMatrix?o.copy(T.matrixWorld):(o.copy(t.matrixWorld).invert(),o.multiply(T.matrixWorld)),s.setFromMatrixScale(o),o.scale(s.set(1/s.x,1/s.y,1/s.z)),l.makeRotationFromQuaternion(i.setFromRotationMatrix(o)),t.isObject3D){const w=d.indexOf(f),I=m?m[w]:a.copy(t.skeleton.boneInverses[w]).invert();l.multiply(I)}l.copyPosition(o)}f.parent&&f.parent.isBone?(f.matrix.copy(f.parent.matrixWorld).invert(),f.matrix.multiply(l)):f.matrix.copy(l),n.preserveHipPosition&&p===n.hip&&f.matrix.setPosition(r.set(0,f.position.y,0)),f.matrix.decompose(f.position,f.quaternion,f.scale),f.updateMatrixWorld()}if(n.preservePosition)for(let x=0;x<d.length;++x)f=d[x],p=n.names[f.name]||f.name,p!==n.hip&&f.position.copy(g[x]);n.preserveMatrix&&t.updateMatrixWorld(!0)}function fa(t,e,n,r={}){r.useFirstFramePosition=r.useFirstFramePosition!==void 0?r.useFirstFramePosition:!1,r.fps=r.fps!==void 0?r.fps:30,r.names=r.names||[],e.isObject3D||(e=ha(e));const i=Math.round(n.duration*(r.fps/1e3)*1e3),s=1/r.fps,a=[],o=new Wi(e),l=wn(t.skeleton),c=[];let d,m,f,p,T;o.clipAction(n).play(),o.update(0),e.updateMatrixWorld();for(let g=0;g<i;++g){const x=g*s;qr(t,e,r);for(let w=0;w<l.length;++w)T=r.names[l[w].name]||l[w].name,f=Yr(T,e.skeleton),f&&(m=l[w],p=c[w]=c[w]||{bone:m},r.hip===T&&(p.pos||(p.pos={times:new Float32Array(i),values:new Float32Array(i*3)}),r.useFirstFramePosition&&(g===0&&(d=m.position.clone()),m.position.sub(d)),p.pos.times[g]=x,m.position.toArray(p.pos.values,g*3)),p.quat||(p.quat={times:new Float32Array(i),values:new Float32Array(i*4)}),p.quat.times[g]=x,m.quaternion.toArray(p.quat.values,g*4));o.update(s),e.updateMatrixWorld()}for(let g=0;g<c.length;++g)p=c[g],p&&(p.pos&&a.push(new Ar(".bones["+p.bone.name+"].position",p.pos.times,p.pos.values)),a.push(new Dn(".bones["+p.bone.name+"].quaternion",p.quat.times,p.quat.values)));return o.uncacheAction(n),new Ir(n.name,-1,a)}function da(t){const e=new Map,n=new Map,r=t.clone();return $r(t,r,function(i,s){e.set(s,i),n.set(i,s)}),r.traverse(function(i){if(!i.isSkinnedMesh)return;const s=i,a=e.get(i),o=a.skeleton.bones;s.skeleton=a.skeleton.clone(),s.bindMatrix.copy(a.bindMatrix),s.skeleton.bones=o.map(function(l){return n.get(l)}),s.bind(s.skeleton,s.bindMatrix)}),r}function Yr(t,e){for(let n=0,r=wn(e);n<r.length;n++)if(t===r[n].name)return r[n]}function wn(t){return Array.isArray(t)?t:t.bones}function ha(t){const e=new Ki(t.bones[0]);return e.skeleton=t,e}function $r(t,e,n){n(t,e);for(let r=0;r<t.children.length;r++)$r(t.children[r],e.children[r],n)}const ma={retarget:qr,retargetClip:fa,clone:da};class pa extends Cr{constructor(e){super(e),this.type=Le}parse(e){const a=function(E,C){switch(E){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(C||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(C||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(C||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(C||""))}},d=`
`,m=function(E,C,j){C=C||1024;let X=E.pos,K=-1,G=0,Z="",q=String.fromCharCode.apply(null,new Uint16Array(E.subarray(X,X+128)));for(;0>(K=q.indexOf(d))&&G<C&&X<E.byteLength;)Z+=q,G+=q.length,X+=128,q+=String.fromCharCode.apply(null,new Uint16Array(E.subarray(X,X+128)));return-1<K?(E.pos+=G+K+1,Z+q.slice(0,K)):!1},f=function(E){const C=/^#\?(\S+)/,j=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,Y=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,X=/^\s*FORMAT=(\S+)\s*$/,K=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,G={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let Z,q;for((E.pos>=E.byteLength||!(Z=m(E)))&&a(1,"no header found"),(q=Z.match(C))||a(3,"bad initial token"),G.valid|=1,G.programtype=q[1],G.string+=Z+`
`;Z=m(E),Z!==!1;){if(G.string+=Z+`
`,Z.charAt(0)==="#"){G.comments+=Z+`
`;continue}if((q=Z.match(j))&&(G.gamma=parseFloat(q[1])),(q=Z.match(Y))&&(G.exposure=parseFloat(q[1])),(q=Z.match(X))&&(G.valid|=2,G.format=q[1]),(q=Z.match(K))&&(G.valid|=4,G.height=parseInt(q[1],10),G.width=parseInt(q[2],10)),G.valid&2&&G.valid&4)break}return G.valid&2||a(3,"missing format specifier"),G.valid&4||a(3,"missing image size specifier"),G},p=function(E,C,j){const Y=C;if(Y<8||Y>32767||E[0]!==2||E[1]!==2||E[2]&128)return new Uint8Array(E);Y!==(E[2]<<8|E[3])&&a(3,"wrong scanline width");const X=new Uint8Array(4*C*j);X.length||a(4,"unable to allocate buffer space");let K=0,G=0;const Z=4*Y,q=new Uint8Array(4),we=new Uint8Array(Z);let Oe=j;for(;Oe>0&&G<E.byteLength;){G+4>E.byteLength&&a(1),q[0]=E[G++],q[1]=E[G++],q[2]=E[G++],q[3]=E[G++],(q[0]!=2||q[1]!=2||(q[2]<<8|q[3])!=Y)&&a(3,"bad rgbe scanline format");let Ce=0,ae;for(;Ce<Z&&G<E.byteLength;){ae=E[G++];const ee=ae>128;if(ee&&(ae-=128),(ae===0||Ce+ae>Z)&&a(3,"bad scanline data"),ee){const re=E[G++];for(let ke=0;ke<ae;ke++)we[Ce++]=re}else we.set(E.subarray(G,G+ae),Ce),Ce+=ae,G+=ae}const Te=Y;for(let ee=0;ee<Te;ee++){let re=0;X[K]=we[ee+re],re+=Y,X[K+1]=we[ee+re],re+=Y,X[K+2]=we[ee+re],re+=Y,X[K+3]=we[ee+re],K+=4}Oe--}return X},T=function(E,C,j,Y){const X=E[C+3],K=Math.pow(2,X-128)/255;j[Y+0]=E[C+0]*K,j[Y+1]=E[C+1]*K,j[Y+2]=E[C+2]*K,j[Y+3]=1},g=function(E,C,j,Y){const X=E[C+3],K=Math.pow(2,X-128)/255;j[Y+0]=Lt.toHalfFloat(Math.min(E[C+0]*K,65504)),j[Y+1]=Lt.toHalfFloat(Math.min(E[C+1]*K,65504)),j[Y+2]=Lt.toHalfFloat(Math.min(E[C+2]*K,65504)),j[Y+3]=Lt.toHalfFloat(1)},x=new Uint8Array(e);x.pos=0;const w=f(x),I=w.width,A=w.height,R=p(x.subarray(x.pos),I,A);let P,D,U;switch(this.type){case Ae:U=R.length/4;const E=new Float32Array(U*4);for(let j=0;j<U;j++)T(R,j*4,E,j*4);P=E,D=Ae;break;case Le:U=R.length/4;const C=new Uint16Array(U*4);for(let j=0;j<U;j++)g(R,j*4,C,j*4);P=C,D=Le;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:I,height:A,data:P,header:w.string,gamma:w.gamma,exposure:w.exposure,type:D}}setDataType(e){return this.type=e,this}load(e,n,r,i){function s(a,o){switch(a.type){case Ae:case Le:"colorSpace"in a?a.colorSpace="srgb-linear":a.encoding=3e3,a.minFilter=xe,a.magFilter=xe,a.generateMipmaps=!1,a.flipY=!0;break}n&&n(a,o)}return super.load(e,s,r,i)}}const Xt="colorSpace"in new tt;class va extends Cr{constructor(e){super(e),this.type=Le}parse(e){const C=Math.pow(2.7182818,2.2);function j(u,h){for(var v=0,S=0;S<65536;++S)(S==0||u[S>>3]&1<<(S&7))&&(h[v++]=S);for(var M=v-1;v<65536;)h[v++]=0;return M}function Y(u){for(var h=0;h<16384;h++)u[h]={},u[h].len=0,u[h].lit=0,u[h].p=null}const X={l:0,c:0,lc:0};function K(u,h,v,S,M){for(;v<u;)h=h<<8|cr(S,M),v+=8;v-=u,X.l=h>>v&(1<<u)-1,X.c=h,X.lc=v}const G=new Array(59);function Z(u){for(var h=0;h<=58;++h)G[h]=0;for(var h=0;h<65537;++h)G[u[h]]+=1;for(var v=0,h=58;h>0;--h){var S=v+G[h]>>1;G[h]=v,v=S}for(var h=0;h<65537;++h){var M=u[h];M>0&&(u[h]=M|G[M]++<<6)}}function q(u,h,v,S,M,b,N){for(var L=v,O=0,F=0;M<=b;M++){if(L.value-v.value>S)return!1;K(6,O,F,u,L);var k=X.l;if(O=X.c,F=X.lc,N[M]=k,k==63){if(L.value-v.value>S)throw"Something wrong with hufUnpackEncTable";K(8,O,F,u,L);var B=X.l+6;if(O=X.c,F=X.lc,M+B>b+1)throw"Something wrong with hufUnpackEncTable";for(;B--;)N[M++]=0;M--}else if(k>=59){var B=k-59+2;if(M+B>b+1)throw"Something wrong with hufUnpackEncTable";for(;B--;)N[M++]=0;M--}}Z(N)}function we(u){return u&63}function Oe(u){return u>>6}function Ce(u,h,v,S){for(;h<=v;h++){var M=Oe(u[h]),b=we(u[h]);if(M>>b)throw"Invalid table entry";if(b>14){var N=S[M>>b-14];if(N.len)throw"Invalid table entry";if(N.lit++,N.p){var L=N.p;N.p=new Array(N.lit);for(var O=0;O<N.lit-1;++O)N.p[O]=L[O]}else N.p=new Array(1);N.p[N.lit-1]=h}else if(b)for(var F=0,O=1<<14-b;O>0;O--){var N=S[(M<<14-b)+F];if(N.len||N.p)throw"Invalid table entry";N.len=b,N.lit=h,F++}}return!0}const ae={c:0,lc:0};function Te(u,h,v,S){u=u<<8|cr(v,S),h+=8,ae.c=u,ae.lc=h}const ee={c:0,lc:0};function re(u,h,v,S,M,b,N,L,O,F){if(u==h){S<8&&(Te(v,S,M,N),v=ae.c,S=ae.lc),S-=8;var k=v>>S,k=new Uint8Array([k])[0];if(O.value+k>F)return!1;for(var B=L[O.value-1];k-- >0;)L[O.value++]=B}else if(O.value<F)L[O.value++]=u;else return!1;ee.c=v,ee.lc=S}function ke(u){return u&65535}function bt(u){var h=ke(u);return h>32767?h-65536:h}const ce={a:0,b:0};function lt(u,h){var v=bt(u),S=bt(h),M=S,b=v+(M&1)+(M>>1),N=b,L=b-M;ce.a=N,ce.b=L}function ct(u,h){var v=ke(u),S=ke(h),M=v-(S>>1)&65535,b=S+M-32768&65535;ce.a=b,ce.b=M}function mi(u,h,v,S,M,b,N){for(var L=N<16384,O=v>M?M:v,F=1,k;F<=O;)F<<=1;for(F>>=1,k=F,F>>=1;F>=1;){for(var B=0,ye=B+b*(M-k),V=b*F,W=b*k,J=S*F,te=S*k,ue,de,_e,Ne;B<=ye;B+=W){for(var he=B,rt=B+S*(v-k);he<=rt;he+=te){var pe=he+J,Ee=he+V,ut=Ee+J;L?(lt(u[he+h],u[Ee+h]),ue=ce.a,_e=ce.b,lt(u[pe+h],u[ut+h]),de=ce.a,Ne=ce.b,lt(ue,de),u[he+h]=ce.a,u[pe+h]=ce.b,lt(_e,Ne),u[Ee+h]=ce.a,u[ut+h]=ce.b):(ct(u[he+h],u[Ee+h]),ue=ce.a,_e=ce.b,ct(u[pe+h],u[ut+h]),de=ce.a,Ne=ce.b,ct(ue,de),u[he+h]=ce.a,u[pe+h]=ce.b,ct(_e,Ne),u[Ee+h]=ce.a,u[ut+h]=ce.b)}if(v&F){var Ee=he+V;L?lt(u[he+h],u[Ee+h]):ct(u[he+h],u[Ee+h]),ue=ce.a,u[Ee+h]=ce.b,u[he+h]=ue}}if(M&F)for(var he=B,rt=B+S*(v-k);he<=rt;he+=te){var pe=he+J;L?lt(u[he+h],u[pe+h]):ct(u[he+h],u[pe+h]),ue=ce.a,u[pe+h]=ce.b,u[he+h]=ue}k=F,F>>=1}return B}function pi(u,h,v,S,M,b,N,L,O,F){for(var k=0,B=0,ye=L,V=Math.trunc(M.value+(b+7)/8);M.value<V;)for(Te(k,B,v,M),k=ae.c,B=ae.lc;B>=14;){var W=k>>B-14&16383,J=h[W];if(J.len)B-=J.len,re(J.lit,N,k,B,v,S,M,O,F,ye),k=ee.c,B=ee.lc;else{if(!J.p)throw"hufDecode issues";var te;for(te=0;te<J.lit;te++){for(var ue=we(u[J.p[te]]);B<ue&&M.value<V;)Te(k,B,v,M),k=ae.c,B=ae.lc;if(B>=ue&&Oe(u[J.p[te]])==(k>>B-ue&(1<<ue)-1)){B-=ue,re(J.p[te],N,k,B,v,S,M,O,F,ye),k=ee.c,B=ee.lc;break}}if(te==J.lit)throw"hufDecode issues"}}var de=8-b&7;for(k>>=de,B-=de;B>0;){var J=h[k<<14-B&16383];if(J.len)B-=J.len,re(J.lit,N,k,B,v,S,M,O,F,ye),k=ee.c,B=ee.lc;else throw"hufDecode issues"}return!0}function rr(u,h,v,S,M,b){var N={value:0},L=v.value,O=ze(h,v),F=ze(h,v);v.value+=4;var k=ze(h,v);if(v.value+=4,O<0||O>=65537||F<0||F>=65537)throw"Something wrong with HUF_ENCSIZE";var B=new Array(65537),ye=new Array(16384);Y(ye);var V=S-(v.value-L);if(q(u,h,v,V,O,F,B),k>8*(S-(v.value-L)))throw"Something wrong with hufUncompress";Ce(B,O,F,ye),pi(B,ye,u,h,v,k,F,b,M,N)}function vi(u,h,v){for(var S=0;S<v;++S)h[S]=u[h[S]]}function ir(u){for(var h=1;h<u.length;h++){var v=u[h-1]+u[h]-128;u[h]=v}}function sr(u,h){for(var v=0,S=Math.floor((u.length+1)/2),M=0,b=u.length-1;!(M>b||(h[M++]=u[v++],M>b));)h[M++]=u[S++]}function ar(u){for(var h=u.byteLength,v=new Array,S=0,M=new DataView(u);h>0;){var b=M.getInt8(S++);if(b<0){var N=-b;h-=N+1;for(var L=0;L<N;L++)v.push(M.getUint8(S++))}else{var N=b;h-=2;for(var O=M.getUint8(S++),L=0;L<N+1;L++)v.push(O)}}return v}function gi(u,h,v,S,M,b){var pe=new DataView(b.buffer),N=v[u.idx[0]].width,L=v[u.idx[0]].height,O=3,F=Math.floor(N/8),k=Math.ceil(N/8),B=Math.ceil(L/8),ye=N-(k-1)*8,V=L-(B-1)*8,W={value:0},J=new Array(O),te=new Array(O),ue=new Array(O),de=new Array(O),_e=new Array(O);for(let fe=0;fe<O;++fe)_e[fe]=h[u.idx[fe]],J[fe]=fe<1?0:J[fe-1]+k*B,te[fe]=new Float32Array(64),ue[fe]=new Uint16Array(64),de[fe]=new Uint16Array(k*64);for(let fe=0;fe<B;++fe){var Ne=8;fe==B-1&&(Ne=V);var he=8;for(let ge=0;ge<k;++ge){ge==k-1&&(he=ye);for(let oe=0;oe<O;++oe)ue[oe].fill(0),ue[oe][0]=M[J[oe]++],xi(W,S,ue[oe]),wi(ue[oe],te[oe]),Ti(te[oe]);yi(te);for(let oe=0;oe<O;++oe)Si(te[oe],de[oe],ge*64)}let Ue=0;for(let ge=0;ge<O;++ge){const oe=v[u.idx[ge]].type;for(let Ke=8*fe;Ke<8*fe+Ne;++Ke){Ue=_e[ge][Ke];for(let Rt=0;Rt<F;++Rt){const je=Rt*64+(Ke&7)*8;pe.setUint16(Ue+0*2*oe,de[ge][je+0],!0),pe.setUint16(Ue+1*2*oe,de[ge][je+1],!0),pe.setUint16(Ue+2*2*oe,de[ge][je+2],!0),pe.setUint16(Ue+3*2*oe,de[ge][je+3],!0),pe.setUint16(Ue+4*2*oe,de[ge][je+4],!0),pe.setUint16(Ue+5*2*oe,de[ge][je+5],!0),pe.setUint16(Ue+6*2*oe,de[ge][je+6],!0),pe.setUint16(Ue+7*2*oe,de[ge][je+7],!0),Ue+=8*2*oe}}if(F!=k)for(let Ke=8*fe;Ke<8*fe+Ne;++Ke){const Rt=_e[ge][Ke]+8*F*2*oe,je=F*64+(Ke&7)*8;for(let gt=0;gt<he;++gt)pe.setUint16(Rt+gt*2*oe,de[ge][je+gt],!0)}}}for(var rt=new Uint16Array(N),pe=new DataView(b.buffer),Ee=0;Ee<O;++Ee){v[u.idx[Ee]].decoded=!0;var ut=v[u.idx[Ee]].type;if(v[Ee].type==2)for(var Kt=0;Kt<L;++Kt){const fe=_e[Ee][Kt];for(var We=0;We<N;++We)rt[We]=pe.getUint16(fe+We*2*ut,!0);for(var We=0;We<N;++We)pe.setFloat32(fe+We*2*ut,H(rt[We]),!0)}}}function xi(u,h,v){for(var S,M=1;M<64;)S=h[u.value],S==65280?M=64:S>>8==255?M+=S&255:(v[M]=S,M++),u.value++}function wi(u,h){h[0]=H(u[0]),h[1]=H(u[1]),h[2]=H(u[5]),h[3]=H(u[6]),h[4]=H(u[14]),h[5]=H(u[15]),h[6]=H(u[27]),h[7]=H(u[28]),h[8]=H(u[2]),h[9]=H(u[4]),h[10]=H(u[7]),h[11]=H(u[13]),h[12]=H(u[16]),h[13]=H(u[26]),h[14]=H(u[29]),h[15]=H(u[42]),h[16]=H(u[3]),h[17]=H(u[8]),h[18]=H(u[12]),h[19]=H(u[17]),h[20]=H(u[25]),h[21]=H(u[30]),h[22]=H(u[41]),h[23]=H(u[43]),h[24]=H(u[9]),h[25]=H(u[11]),h[26]=H(u[18]),h[27]=H(u[24]),h[28]=H(u[31]),h[29]=H(u[40]),h[30]=H(u[44]),h[31]=H(u[53]),h[32]=H(u[10]),h[33]=H(u[19]),h[34]=H(u[23]),h[35]=H(u[32]),h[36]=H(u[39]),h[37]=H(u[45]),h[38]=H(u[52]),h[39]=H(u[54]),h[40]=H(u[20]),h[41]=H(u[22]),h[42]=H(u[33]),h[43]=H(u[38]),h[44]=H(u[46]),h[45]=H(u[51]),h[46]=H(u[55]),h[47]=H(u[60]),h[48]=H(u[21]),h[49]=H(u[34]),h[50]=H(u[37]),h[51]=H(u[47]),h[52]=H(u[50]),h[53]=H(u[56]),h[54]=H(u[59]),h[55]=H(u[61]),h[56]=H(u[35]),h[57]=H(u[36]),h[58]=H(u[48]),h[59]=H(u[49]),h[60]=H(u[57]),h[61]=H(u[58]),h[62]=H(u[62]),h[63]=H(u[63])}function Ti(u){const h=.5*Math.cos(.7853975),v=.5*Math.cos(3.14159/16),S=.5*Math.cos(3.14159/8),M=.5*Math.cos(3*3.14159/16),b=.5*Math.cos(5*3.14159/16),N=.5*Math.cos(3*3.14159/8),L=.5*Math.cos(7*3.14159/16);for(var O=new Array(4),F=new Array(4),k=new Array(4),B=new Array(4),ye=0;ye<8;++ye){var V=ye*8;O[0]=S*u[V+2],O[1]=N*u[V+2],O[2]=S*u[V+6],O[3]=N*u[V+6],F[0]=v*u[V+1]+M*u[V+3]+b*u[V+5]+L*u[V+7],F[1]=M*u[V+1]-L*u[V+3]-v*u[V+5]-b*u[V+7],F[2]=b*u[V+1]-v*u[V+3]+L*u[V+5]+M*u[V+7],F[3]=L*u[V+1]-b*u[V+3]+M*u[V+5]-v*u[V+7],k[0]=h*(u[V+0]+u[V+4]),k[3]=h*(u[V+0]-u[V+4]),k[1]=O[0]+O[3],k[2]=O[1]-O[2],B[0]=k[0]+k[1],B[1]=k[3]+k[2],B[2]=k[3]-k[2],B[3]=k[0]-k[1],u[V+0]=B[0]+F[0],u[V+1]=B[1]+F[1],u[V+2]=B[2]+F[2],u[V+3]=B[3]+F[3],u[V+4]=B[3]-F[3],u[V+5]=B[2]-F[2],u[V+6]=B[1]-F[1],u[V+7]=B[0]-F[0]}for(var W=0;W<8;++W)O[0]=S*u[16+W],O[1]=N*u[16+W],O[2]=S*u[48+W],O[3]=N*u[48+W],F[0]=v*u[8+W]+M*u[24+W]+b*u[40+W]+L*u[56+W],F[1]=M*u[8+W]-L*u[24+W]-v*u[40+W]-b*u[56+W],F[2]=b*u[8+W]-v*u[24+W]+L*u[40+W]+M*u[56+W],F[3]=L*u[8+W]-b*u[24+W]+M*u[40+W]-v*u[56+W],k[0]=h*(u[W]+u[32+W]),k[3]=h*(u[W]-u[32+W]),k[1]=O[0]+O[3],k[2]=O[1]-O[2],B[0]=k[0]+k[1],B[1]=k[3]+k[2],B[2]=k[3]-k[2],B[3]=k[0]-k[1],u[0+W]=B[0]+F[0],u[8+W]=B[1]+F[1],u[16+W]=B[2]+F[2],u[24+W]=B[3]+F[3],u[32+W]=B[3]-F[3],u[40+W]=B[2]-F[2],u[48+W]=B[1]-F[1],u[56+W]=B[0]-F[0]}function yi(u){for(var h=0;h<64;++h){var v=u[0][h],S=u[1][h],M=u[2][h];u[0][h]=v+1.5747*M,u[1][h]=v-.1873*S-.4682*M,u[2][h]=v+1.8556*S}}function Si(u,h,v){for(var S=0;S<64;++S)h[v+S]=Lt.toHalfFloat(_i(u[S]))}function _i(u){return u<=1?Math.sign(u)*Math.pow(Math.abs(u),2.2):Math.sign(u)*Math.pow(C,Math.abs(u)-1)}function or(u){return new DataView(u.array.buffer,u.offset.value,u.size)}function Ei(u){var h=u.viewer.buffer.slice(u.offset.value,u.offset.value+u.size),v=new Uint8Array(ar(h)),S=new Uint8Array(v.length);return ir(v),sr(v,S),new DataView(S.buffer)}function Sn(u){var h=u.array.slice(u.offset.value,u.offset.value+u.size),v=fn(h),S=new Uint8Array(v.length);return ir(v),sr(v,S),new DataView(S.buffer)}function Mi(u){for(var h=u.viewer,v={value:u.offset.value},S=new Uint16Array(u.width*u.scanlineBlockSize*(u.channels*u.type)),M=new Uint8Array(8192),b=0,N=new Array(u.channels),L=0;L<u.channels;L++)N[L]={},N[L].start=b,N[L].end=N[L].start,N[L].nx=u.width,N[L].ny=u.lines,N[L].size=u.type,b+=N[L].nx*N[L].ny*N[L].size;var O=jt(h,v),F=jt(h,v);if(F>=8192)throw"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";if(O<=F)for(var L=0;L<F-O+1;L++)M[L+O]=Ut(h,v);var k=new Uint16Array(65536),B=j(M,k),ye=ze(h,v);rr(u.array,h,v,ye,S,b);for(var L=0;L<u.channels;++L)for(var V=N[L],W=0;W<N[L].size;++W)mi(S,V.start+W,V.nx,V.size,V.ny,V.nx*V.size,B);vi(k,S,b);for(var J=0,te=new Uint8Array(S.buffer.byteLength),ue=0;ue<u.lines;ue++)for(var de=0;de<u.channels;de++){var V=N[de],_e=V.nx*V.size,Ne=new Uint8Array(S.buffer,V.end*2,_e*2);te.set(Ne,J),J+=_e*2,V.end+=_e}return new DataView(te.buffer)}function bi(u){var h=u.array.slice(u.offset.value,u.offset.value+u.size),v=fn(h);const S=u.lines*u.channels*u.width,M=u.type==1?new Uint16Array(S):new Uint32Array(S);let b=0,N=0;const L=new Array(4);for(let O=0;O<u.lines;O++)for(let F=0;F<u.channels;F++){let k=0;switch(u.type){case 1:L[0]=b,L[1]=L[0]+u.width,b=L[1]+u.width;for(let B=0;B<u.width;++B){const ye=v[L[0]++]<<8|v[L[1]++];k+=ye,M[N]=k,N++}break;case 2:L[0]=b,L[1]=L[0]+u.width,L[2]=L[1]+u.width,b=L[2]+u.width;for(let B=0;B<u.width;++B){const ye=v[L[0]++]<<24|v[L[1]++]<<16|v[L[2]++]<<8;k+=ye,M[N]=k,N++}break}}return new DataView(M.buffer)}function lr(u){var h=u.viewer,v={value:u.offset.value},S=new Uint8Array(u.width*u.lines*(u.channels*u.type*2)),M={version:Ve(h,v),unknownUncompressedSize:Ve(h,v),unknownCompressedSize:Ve(h,v),acCompressedSize:Ve(h,v),dcCompressedSize:Ve(h,v),rleCompressedSize:Ve(h,v),rleUncompressedSize:Ve(h,v),rleRawSize:Ve(h,v),totalAcUncompressedCount:Ve(h,v),totalDcUncompressedCount:Ve(h,v),acCompression:Ve(h,v)};if(M.version<2)throw"EXRLoader.parse: "+Wt.compression+" version "+M.version+" is unsupported";for(var b=new Array,N=jt(h,v)-2;N>0;){var L=ln(h.buffer,v),O=Ut(h,v),F=O>>2&3,k=(O>>4)-1,B=new Int8Array([k])[0],ye=Ut(h,v);b.push({name:L,index:B,type:ye,compression:F}),N-=L.length+3}for(var V=Wt.channels,W=new Array(u.channels),J=0;J<u.channels;++J){var te=W[J]={},ue=V[J];te.name=ue.name,te.compression=0,te.decoded=!1,te.type=ue.pixelType,te.pLinear=ue.pLinear,te.width=u.width,te.height=u.lines}for(var de={idx:new Array(3)},_e=0;_e<u.channels;++_e)for(var te=W[_e],J=0;J<b.length;++J){var Ne=b[J];te.name==Ne.name&&(te.compression=Ne.compression,Ne.index>=0&&(de.idx[Ne.index]=_e),te.offset=_e)}if(M.acCompressedSize>0)switch(M.acCompression){case 0:var pe=new Uint16Array(M.totalAcUncompressedCount);rr(u.array,h,v,M.acCompressedSize,pe,M.totalAcUncompressedCount);break;case 1:var he=u.array.slice(v.value,v.value+M.totalAcUncompressedCount),rt=fn(he),pe=new Uint16Array(rt.buffer);v.value+=M.totalAcUncompressedCount;break}if(M.dcCompressedSize>0){var Ee={array:u.array,offset:v,size:M.dcCompressedSize},ut=new Uint16Array(Sn(Ee).buffer);v.value+=M.dcCompressedSize}if(M.rleRawSize>0){var he=u.array.slice(v.value,v.value+M.rleCompressedSize),rt=fn(he),Kt=ar(rt.buffer);v.value+=M.rleCompressedSize}for(var We=0,fe=new Array(W.length),J=0;J<fe.length;++J)fe[J]=new Array;for(var Ue=0;Ue<u.lines;++Ue)for(var ge=0;ge<W.length;++ge)fe[ge].push(We),We+=W[ge].width*u.type*2;gi(de,fe,W,pe,ut,S);for(var J=0;J<W.length;++J){var te=W[J];if(!te.decoded)switch(te.compression){case 2:for(var oe=0,Ke=0,Ue=0;Ue<u.lines;++Ue){for(var Rt=fe[J][oe],je=0;je<te.width;++je){for(var gt=0;gt<2*te.type;++gt)S[Rt++]=Kt[Ke+gt*te.width*te.height];Ke++}oe++}break;case 1:default:throw"EXRLoader.parse: unsupported channel compression"}}return new DataView(S.buffer)}function ln(u,h){for(var v=new Uint8Array(u),S=0;v[h.value+S]!=0;)S+=1;var M=new TextDecoder().decode(v.slice(h.value,h.value+S));return h.value=h.value+S+1,M}function Ri(u,h,v){var S=new TextDecoder().decode(new Uint8Array(u).slice(h.value,h.value+v));return h.value=h.value+v,S}function Ai(u,h){var v=Gt(u,h),S=ze(u,h);return[v,S]}function Ii(u,h){var v=ze(u,h),S=ze(u,h);return[v,S]}function Gt(u,h){var v=u.getInt32(h.value,!0);return h.value=h.value+4,v}function ze(u,h){var v=u.getUint32(h.value,!0);return h.value=h.value+4,v}function cr(u,h){var v=u[h.value];return h.value=h.value+1,v}function Ut(u,h){var v=u.getUint8(h.value);return h.value=h.value+1,v}const Ve=function(u,h){let v;return"getBigInt64"in DataView.prototype?v=Number(u.getBigInt64(h.value,!0)):v=u.getUint32(h.value+4,!0)+Number(u.getUint32(h.value,!0)<<32),h.value+=8,v};function De(u,h){var v=u.getFloat32(h.value,!0);return h.value+=4,v}function Ci(u,h){return Lt.toHalfFloat(De(u,h))}function H(u){var h=(u&31744)>>10,v=u&1023;return(u>>15?-1:1)*(h?h===31?v?NaN:1/0:Math.pow(2,h-15)*(1+v/1024):6103515625e-14*(v/1024))}function jt(u,h){var v=u.getUint16(h.value,!0);return h.value+=2,v}function Di(u,h){return H(jt(u,h))}function Ui(u,h,v,S){for(var M=v.value,b=[];v.value<M+S-1;){var N=ln(h,v),L=Gt(u,v),O=Ut(u,v);v.value+=3;var F=Gt(u,v),k=Gt(u,v);b.push({name:N,pixelType:L,pLinear:O,xSampling:F,ySampling:k})}return v.value+=1,b}function Li(u,h){var v=De(u,h),S=De(u,h),M=De(u,h),b=De(u,h),N=De(u,h),L=De(u,h),O=De(u,h),F=De(u,h);return{redX:v,redY:S,greenX:M,greenY:b,blueX:N,blueY:L,whiteX:O,whiteY:F}}function Pi(u,h){var v=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],S=Ut(u,h);return v[S]}function Ni(u,h){var v=ze(u,h),S=ze(u,h),M=ze(u,h),b=ze(u,h);return{xMin:v,yMin:S,xMax:M,yMax:b}}function Bi(u,h){var v=["INCREASING_Y"],S=Ut(u,h);return v[S]}function Fi(u,h){var v=De(u,h),S=De(u,h);return[v,S]}function Oi(u,h){var v=De(u,h),S=De(u,h),M=De(u,h);return[v,S,M]}function ki(u,h,v,S,M){if(S==="string"||S==="stringvector"||S==="iccProfile")return Ri(h,v,M);if(S==="chlist")return Ui(u,h,v,M);if(S==="chromaticities")return Li(u,v);if(S==="compression")return Pi(u,v);if(S==="box2i")return Ni(u,v);if(S==="lineOrder")return Bi(u,v);if(S==="float")return De(u,v);if(S==="v2f")return Fi(u,v);if(S==="v3f")return Oi(u,v);if(S==="int")return Gt(u,v);if(S==="rational")return Ai(u,v);if(S==="timecode")return Ii(u,v);if(S==="preview")return v.value+=M,"skipped";v.value+=M}function zi(u,h,v){const S={};if(u.getUint32(0,!0)!=20000630)throw"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";S.version=u.getUint8(4);const M=u.getUint8(5);S.spec={singleTile:!!(M&2),longName:!!(M&4),deepFormat:!!(M&8),multiPart:!!(M&16)},v.value=8;for(var b=!0;b;){var N=ln(h,v);if(N==0)b=!1;else{var L=ln(h,v),O=ze(u,v),F=ki(u,h,v,L,O);F===void 0?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${L}'.`):S[N]=F}}if(M&-5)throw console.error("EXRHeader:",S),"THREE.EXRLoader: provided file is currently unsupported.";return S}function Hi(u,h,v,S,M){const b={size:0,viewer:h,array:v,offset:S,width:u.dataWindow.xMax-u.dataWindow.xMin+1,height:u.dataWindow.yMax-u.dataWindow.yMin+1,channels:u.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:u.channels[0].pixelType,uncompress:null,getter:null,format:null,[Xt?"colorSpace":"encoding"]:null};switch(u.compression){case"NO_COMPRESSION":b.lines=1,b.uncompress=or;break;case"RLE_COMPRESSION":b.lines=1,b.uncompress=Ei;break;case"ZIPS_COMPRESSION":b.lines=1,b.uncompress=Sn;break;case"ZIP_COMPRESSION":b.lines=16,b.uncompress=Sn;break;case"PIZ_COMPRESSION":b.lines=32,b.uncompress=Mi;break;case"PXR24_COMPRESSION":b.lines=16,b.uncompress=bi;break;case"DWAA_COMPRESSION":b.lines=32,b.uncompress=lr;break;case"DWAB_COMPRESSION":b.lines=256,b.uncompress=lr;break;default:throw"EXRLoader.parse: "+u.compression+" is unsupported"}if(b.scanlineBlockSize=b.lines,b.type==1)switch(M){case Ae:b.getter=Di,b.inputSize=2;break;case Le:b.getter=jt,b.inputSize=2;break}else if(b.type==2)switch(M){case Ae:b.getter=De,b.inputSize=4;break;case Le:b.getter=Ci,b.inputSize=4}else throw"EXRLoader.parse: unsupported pixelType "+b.type+" for "+u.compression+".";b.blockCount=(u.dataWindow.yMax+1)/b.scanlineBlockSize;for(var N=0;N<b.blockCount;N++)Ve(h,S);b.outputChannels=b.channels==3?4:b.channels;const L=b.width*b.height*b.outputChannels;switch(M){case Ae:b.byteArray=new Float32Array(L),b.channels<b.outputChannels&&b.byteArray.fill(1,0,L);break;case Le:b.byteArray=new Uint16Array(L),b.channels<b.outputChannels&&b.byteArray.fill(15360,0,L);break;default:console.error("THREE.EXRLoader: unsupported type: ",M);break}return b.bytesPerLine=b.width*b.inputSize*b.channels,b.outputChannels==4?b.format=nt:b.format=Zi,Xt?b.colorSpace="srgb-linear":b.encoding=3e3,b}const cn=new DataView(e),Gi=new Uint8Array(e),Vt={value:0},Wt=zi(cn,e,Vt),ne=Hi(Wt,cn,Gi,Vt,this.type),ur={value:0},ji={R:0,G:1,B:2,A:3,Y:0};for(let u=0;u<ne.height/ne.scanlineBlockSize;u++){const h=ze(cn,Vt);ne.size=ze(cn,Vt),ne.lines=h+ne.scanlineBlockSize>ne.height?ne.height-h:ne.scanlineBlockSize;const S=ne.size<ne.lines*ne.bytesPerLine?ne.uncompress(ne):or(ne);Vt.value+=ne.size;for(let M=0;M<ne.scanlineBlockSize;M++){const b=M+u*ne.scanlineBlockSize;if(b>=ne.height)break;for(let N=0;N<ne.channels;N++){const L=ji[Wt.channels[N].name];for(let O=0;O<ne.width;O++){ur.value=(M*(ne.channels*ne.width)+N*ne.width+O)*ne.inputSize;const F=(ne.height-1-b)*(ne.width*ne.outputChannels)+O*ne.outputChannels+L;ne.byteArray[F]=ne.getter(S,ur)}}}}return{header:Wt,width:ne.width,height:ne.height,data:ne.byteArray,format:ne.format,[Xt?"colorSpace":"encoding"]:ne[Xt?"colorSpace":"encoding"],type:this.type}}setDataType(e){return this.type=e,this}load(e,n,r,i){function s(a,o){Xt?a.colorSpace=o.colorSpace:a.encoding=o.encoding,a.minFilter=xe,a.magFilter=xe,a.generateMipmaps=!1,a.flipY=!1,n&&n(a,o)}return super.load(e,s,r,i)}}const ga=()=>parseInt(Ft.replace(/\D+/g,"")),xa=ga();function wa(t,{keys:e=["near","far","color","distance","decay","penumbra","angle","intensity","skeleton","visible","castShadow","receiveShadow","morphTargetDictionary","morphTargetInfluences","name","geometry","material","position","rotation","scale","up","userData","bindMode","bindMatrix","bindMatrixInverse","skeleton"],deep:n,inject:r,castShadow:i,receiveShadow:s}){let a={};for(const o of e)a[o]=t[o];return n&&(a.geometry&&n!=="materialsOnly"&&(a.geometry=a.geometry.clone()),a.material&&n!=="geometriesOnly"&&(a.material=a.material.clone())),r&&(typeof r=="function"?a={...a,children:r(t)}:y.isValidElement(r)?a={...a,children:r}:a={...a,...r}),t instanceof st&&(i&&(a.castShadow=!0),s&&(a.receiveShadow=!0)),a}const Bt=y.forwardRef(({isChild:t=!1,object:e,children:n,deep:r,castShadow:i,receiveShadow:s,inject:a,keys:o,...l},c)=>{const d={keys:o,deep:r,inject:a,castShadow:i,receiveShadow:s};if(e=y.useMemo(()=>{if(t===!1&&!Array.isArray(e)){let T=!1;if(e.traverse(g=>{g.isSkinnedMesh&&(T=!0)}),T)return ma.clone(e)}return e},[e,t]),Array.isArray(e))return y.createElement("group",dt({},l,{ref:c}),e.map(T=>y.createElement(Bt,dt({key:T.uuid,object:T},d))),n);const{children:m,...f}=wa(e,d),p=e.type[0].toLowerCase()+e.type.slice(1);return y.createElement(p,dt({},f,l,{ref:c}),e.children.map(T=>T.type==="Bone"?y.createElement("primitive",dt({key:T.uuid,object:T},d)):y.createElement(Bt,dt({key:T.uuid,object:T},d,{isChild:!0}))),n,m)});function Ta({resolution:t=256,near:e=.1,far:n=1e3,envMap:r,fog:i}={}){const s=Ie(({gl:f})=>f),a=Ie(({scene:f})=>f),o=y.useMemo(()=>{const f=new Dr(t);return f.texture.type=Le,f},[t]);y.useEffect(()=>()=>{o.dispose()},[o]);const l=y.useMemo(()=>new Xi(e,n,o),[e,n,o]);let c,d;const m=y.useCallback(()=>{c=a.fog,d=a.background,a.background=r||d,a.fog=i||c,l.update(s,a),a.fog=c,a.background=d},[s,a,l]);return{fbo:o,camera:l,update:m}}var Qr={exports:{}};(function(t,e){(function(n,r){t.exports=r()})(qi,function(){var n=function(){function r(p){return a.appendChild(p.dom),p}function i(p){for(var T=0;T<a.children.length;T++)a.children[T].style.display=T===p?"block":"none";s=p}var s=0,a=document.createElement("div");a.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",a.addEventListener("click",function(p){p.preventDefault(),i(++s%a.children.length)},!1);var o=(performance||Date).now(),l=o,c=0,d=r(new n.Panel("FPS","#0ff","#002")),m=r(new n.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var f=r(new n.Panel("MB","#f08","#201"));return i(0),{REVISION:16,dom:a,addPanel:r,showPanel:i,begin:function(){o=(performance||Date).now()},end:function(){c++;var p=(performance||Date).now();if(m.update(p-o,200),p>l+1e3&&(d.update(1e3*c/(p-l),100),l=p,c=0,f)){var T=performance.memory;f.update(T.usedJSHeapSize/1048576,T.jsHeapSizeLimit/1048576)}return p},update:function(){o=this.end()},domElement:a,setMode:i}};return n.Panel=function(r,i,s){var a=1/0,o=0,l=Math.round,c=l(window.devicePixelRatio||1),d=80*c,m=48*c,f=3*c,p=2*c,T=3*c,g=15*c,x=74*c,w=30*c,I=document.createElement("canvas");I.width=d,I.height=m,I.style.cssText="width:80px;height:48px";var A=I.getContext("2d");return A.font="bold "+9*c+"px Helvetica,Arial,sans-serif",A.textBaseline="top",A.fillStyle=s,A.fillRect(0,0,d,m),A.fillStyle=i,A.fillText(r,f,p),A.fillRect(T,g,x,w),A.fillStyle=s,A.globalAlpha=.9,A.fillRect(T,g,x,w),{dom:I,update:function(R,P){a=Math.min(a,R),o=Math.max(o,R),A.fillStyle=s,A.globalAlpha=1,A.fillRect(0,0,d,g),A.fillStyle=i,A.fillText(l(R)+" "+r+" ("+l(a)+"-"+l(o)+")",f,p),A.drawImage(I,T+c,g,x-c,w,T,g,x-c,w),A.fillRect(T+x-c,g,c,w),A.fillStyle=s,A.globalAlpha=.9,A.fillRect(T+x-c,g,c,l((1-R/P)*w))}}},n})})(Qr);var ya=Qr.exports;const Sa=Yi(ya);function _a(t,e=[],n){const[r,i]=y.useState();return y.useLayoutEffect(()=>{const s=t();return i(s),()=>void 0},e),r}function Ea({showPanel:t=0,className:e,parent:n}){const r=_a(()=>new Sa,[]);return y.useEffect(()=>{if(r){const i=n&&n.current||document.body;r.showPanel(t),i==null||i.appendChild(r.dom);const s=(e??"").split(" ").filter(l=>l);s.length&&r.dom.classList.add(...s);const a=$i(()=>r.begin()),o=Qi(()=>r.end());return()=>{s.length&&r.dom.classList.remove(...s),i==null||i.removeChild(r.dom),a(),o()}}},[n,r,e,t]),null}class Ma extends $e{constructor(e=new me){super({uniforms:{inputBuffer:new z(null),depthBuffer:new z(null),resolution:new z(new me),texelSize:new z(new me),halfTexelSize:new z(new me),kernel:new z(0),scale:new z(1),cameraNear:new z(0),cameraFar:new z(1),minDepthThreshold:new z(0),maxDepthThreshold:new z(1),depthScale:new z(0),depthToBlurRatioBias:new z(.25)},fragmentShader:`#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
            depthFactor *= depthScale;
            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));
          #endif
          
          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));
          gl_FragColor = sum * 0.25 ;

          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <${xa>=154?"colorspace_fragment":"encodings_fragment"}>
        }`,vertexShader:`uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,blending:ot,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,n){this.uniforms.texelSize.value.set(e,n),this.uniforms.halfTexelSize.value.set(e,n).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class ba{constructor({gl:e,resolution:n,width:r=500,height:i=500,minDepthThreshold:s=0,maxDepthThreshold:a=1,depthScale:o=0,depthToBlurRatioBias:l=.25}){this.renderToScreen=!1,this.renderTargetA=new Re(n,n,{minFilter:xe,magFilter:xe,stencilBuffer:!1,depthBuffer:!1,type:Le}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new Ma,this.convolutionMaterial.setTexelSize(1/r,1/i),this.convolutionMaterial.setResolution(new me(r,i)),this.scene=new nn,this.camera=new Ur,this.convolutionMaterial.uniforms.minDepthThreshold.value=s,this.convolutionMaterial.uniforms.maxDepthThreshold.value=a,this.convolutionMaterial.uniforms.depthScale.value=o,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=l,this.convolutionMaterial.defines.USE_DEPTH=o>0;const c=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),d=new Float32Array([0,0,2,0,0,2]),m=new Ot;m.setAttribute("position",new be(c,3)),m.setAttribute("uv",new be(d,2)),this.screen=new st(m,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,n,r){const i=this.scene,s=this.camera,a=this.renderTargetA,o=this.renderTargetB;let l=this.convolutionMaterial,c=l.uniforms;c.depthBuffer.value=n.depthTexture;const d=l.kernel;let m=n,f,p,T;for(p=0,T=d.length-1;p<T;++p)f=p&1?o:a,c.kernel.value=d[p],c.inputBuffer.value=m.texture,e.setRenderTarget(f),e.render(i,s),m=f;c.kernel.value=d[p],c.inputBuffer.value=m.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(i,s)}}let Ra=class extends zn{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){var n;(n=e.defines)!=null&&n.USE_UV||(e.defines.USE_UV=""),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader=`
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>",`#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`),e.fragmentShader=`
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
			  uniform float cameraFar;
        uniform bool hasBlur;
        uniform float mixBlur;
        uniform float mirror;
        uniform float mixStrength;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float mixContrast;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec4 my_vUv;
        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>",`#include <emissivemap_fragment>

      float distortionFactor = 0.0;
      #ifdef USE_DISTORTION
        distortionFactor = texture2D(distortionMap, vUv).r * distortion;
      #endif

      vec4 new_vUv = my_vUv;
      new_vUv.x += distortionFactor;
      new_vUv.y += distortionFactor;

      vec4 base = texture2DProj(tDiffuse, new_vUv);
      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);

      vec4 merge = base;

      #ifdef USE_NORMALMAP
        vec2 normal_uv = vec2(0.0);
        vec4 normalColor = texture2D(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;
        vec4 base_normal = texture2D(tDiffuse, normal_uv);
        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);
        merge = base_normal;
        blur = blur_normal;
      #endif

      float depthFactor = 0.0001;
      float blurFactor = 0.0;

      #ifdef USE_DEPTH
        vec4 depth = texture2DProj(tDepth, new_vUv);
        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
        depthFactor *= depthScale;
        depthFactor = max(0.0001, min(1.0, depthFactor));

        #ifdef USE_BLUR
          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);
          merge = merge * min(1.0, depthFactor + 0.5);
        #else
          merge = merge * depthFactor;
        #endif

      #endif

      float reflectorRoughnessFactor = roughness;
      #ifdef USE_ROUGHNESSMAP
        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );
        reflectorRoughnessFactor *= reflectorTexelRoughness.g;
      #endif

      #ifdef USE_BLUR
        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);
        merge = mix(merge, blur, blurFactor);
      #endif

      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);
      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;
      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;
      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;

      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);
      `)}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}};const Aa=y.forwardRef(({mixBlur:t=0,mixStrength:e=1,resolution:n=256,blur:r=[0,0],minDepthThreshold:i=.9,maxDepthThreshold:s=1,depthScale:a=0,depthToBlurRatioBias:o=.25,mirror:l=0,distortion:c=1,mixContrast:d=1,distortionMap:m,reflectorOffset:f=0,...p},T)=>{Hn({MeshReflectorMaterialImpl:Ra});const g=Ie(({gl:Te})=>Te),x=Ie(({camera:Te})=>Te),w=Ie(({scene:Te})=>Te);r=Array.isArray(r)?r:[r,r];const I=r[0]+r[1]>0,A=y.useRef(null);y.useImperativeHandle(T,()=>A.current,[]);const[R]=y.useState(()=>new Ji),[P]=y.useState(()=>new Q),[D]=y.useState(()=>new Q),[U]=y.useState(()=>new Q),[E]=y.useState(()=>new it),[C]=y.useState(()=>new Q(0,0,-1)),[j]=y.useState(()=>new vn),[Y]=y.useState(()=>new Q),[X]=y.useState(()=>new Q),[K]=y.useState(()=>new vn),[G]=y.useState(()=>new it),[Z]=y.useState(()=>new Gn),q=y.useCallback(()=>{var Te;const ee=A.current.parent||((Te=A.current)==null?void 0:Te.__r3f.parent);if(!ee||(D.setFromMatrixPosition(ee.matrixWorld),U.setFromMatrixPosition(x.matrixWorld),E.extractRotation(ee.matrixWorld),P.set(0,0,1),P.applyMatrix4(E),D.addScaledVector(P,f),Y.subVectors(D,U),Y.dot(P)>0))return;Y.reflect(P).negate(),Y.add(D),E.extractRotation(x.matrixWorld),C.set(0,0,-1),C.applyMatrix4(E),C.add(U),X.subVectors(D,C),X.reflect(P).negate(),X.add(D),Z.position.copy(Y),Z.up.set(0,1,0),Z.up.applyMatrix4(E),Z.up.reflect(P),Z.lookAt(X),Z.far=x.far,Z.updateMatrixWorld(),Z.projectionMatrix.copy(x.projectionMatrix),G.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),G.multiply(Z.projectionMatrix),G.multiply(Z.matrixWorldInverse),G.multiply(ee.matrixWorld),R.setFromNormalAndCoplanarPoint(P,D),R.applyMatrix4(Z.matrixWorldInverse),j.set(R.normal.x,R.normal.y,R.normal.z,R.constant);const re=Z.projectionMatrix;K.x=(Math.sign(j.x)+re.elements[8])/re.elements[0],K.y=(Math.sign(j.y)+re.elements[9])/re.elements[5],K.z=-1,K.w=(1+re.elements[10])/re.elements[14],j.multiplyScalar(2/j.dot(K)),re.elements[2]=j.x,re.elements[6]=j.y,re.elements[10]=j.z+1,re.elements[14]=j.w},[x,f]),[we,Oe,Ce,ae]=y.useMemo(()=>{const Te={minFilter:xe,magFilter:xe,type:Le},ee=new Re(n,n,Te);ee.depthBuffer=!0,ee.depthTexture=new Lr(n,n),ee.depthTexture.format=es,ee.depthTexture.type=ts;const re=new Re(n,n,Te),ke=new ba({gl:g,resolution:n,width:r[0],height:r[1],minDepthThreshold:i,maxDepthThreshold:s,depthScale:a,depthToBlurRatioBias:o}),bt={mirror:l,textureMatrix:G,mixBlur:t,tDiffuse:ee.texture,tDepth:ee.depthTexture,tDiffuseBlur:re.texture,hasBlur:I,mixStrength:e,minDepthThreshold:i,maxDepthThreshold:s,depthScale:a,depthToBlurRatioBias:o,distortion:c,distortionMap:m,mixContrast:d,"defines-USE_BLUR":I?"":void 0,"defines-USE_DEPTH":a>0?"":void 0,"defines-USE_DISTORTION":m?"":void 0};return[ee,re,ke,bt]},[g,r,G,n,l,I,t,e,i,s,a,o,c,m,d]);return Ye(()=>{var Te;const ee=A.current.parent||((Te=A.current)==null?void 0:Te.__r3f.parent);if(!ee)return;ee.visible=!1;const re=g.xr.enabled,ke=g.shadowMap.autoUpdate;q(),g.xr.enabled=!1,g.shadowMap.autoUpdate=!1,g.setRenderTarget(we),g.state.buffers.depth.setMask(!0),g.autoClear||g.clear(),g.render(w,Z),I&&Ce.render(g,we,Oe),g.xr.enabled=re,g.shadowMap.autoUpdate=ke,ee.visible=!0,g.setRenderTarget(null)}),y.createElement("meshReflectorMaterialImpl",dt({attach:"material",key:"key"+ae["defines-USE_BLUR"]+ae["defines-USE_DEPTH"]+ae["defines-USE_DISTORTION"],ref:A},ae,p))}),Jr=(t,e,n)=>{let r;switch(t){case Be:r=new Uint8ClampedArray(e*n*4);break;case Le:r=new Uint16Array(e*n*4);break;case Br:r=new Uint32Array(e*n*4);break;case ss:r=new Int8Array(e*n*4);break;case is:r=new Int16Array(e*n*4);break;case rs:r=new Int32Array(e*n*4);break;case Ae:r=new Float32Array(e*n*4);break;default:throw new Error("Unsupported data type")}return r};let dn;const Ia=(t,e,n,r)=>{if(dn!==void 0)return dn;const i=new Re(1,1,r);e.setRenderTarget(i);const s=new st(new jn,new mt({color:16777215}));e.render(s,n),e.setRenderTarget(null);const a=Jr(t,i.width,i.height);return e.readRenderTargetPixels(i,0,0,i.width,i.height,a),i.dispose(),s.geometry.dispose(),s.material.dispose(),dn=a[0]!==0,dn};class Xn{constructor(e){var n,r,i,s,a,o,l,c,d,m,f,p,T,g,x,w;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(A){throw this._renderer.setRenderTarget(null),A}this._renderer.setRenderTarget(null)},this._width=e.width,this._height=e.height,this._type=e.type,this._colorSpace=e.colorSpace;const I={format:nt,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:((n=e.renderTargetOptions)===null||n===void 0?void 0:n.anisotropy)!==void 0?(r=e.renderTargetOptions)===null||r===void 0?void 0:r.anisotropy:1,generateMipmaps:((i=e.renderTargetOptions)===null||i===void 0?void 0:i.generateMipmaps)!==void 0?(s=e.renderTargetOptions)===null||s===void 0?void 0:s.generateMipmaps:!1,magFilter:((a=e.renderTargetOptions)===null||a===void 0?void 0:a.magFilter)!==void 0?(o=e.renderTargetOptions)===null||o===void 0?void 0:o.magFilter:xe,minFilter:((l=e.renderTargetOptions)===null||l===void 0?void 0:l.minFilter)!==void 0?(c=e.renderTargetOptions)===null||c===void 0?void 0:c.minFilter:xe,samples:((d=e.renderTargetOptions)===null||d===void 0?void 0:d.samples)!==void 0?(m=e.renderTargetOptions)===null||m===void 0?void 0:m.samples:void 0,wrapS:((f=e.renderTargetOptions)===null||f===void 0?void 0:f.wrapS)!==void 0?(p=e.renderTargetOptions)===null||p===void 0?void 0:p.wrapS:qe,wrapT:((T=e.renderTargetOptions)===null||T===void 0?void 0:T.wrapT)!==void 0?(g=e.renderTargetOptions)===null||g===void 0?void 0:g.wrapT:qe};if(this._material=e.material,e.renderer?this._renderer=e.renderer:(this._renderer=Xn.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new nn,this._camera=new Pr,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!Ia(this._type,this._renderer,this._camera,I)){let A;switch(this._type){case Le:A=this._renderer.extensions.has("EXT_color_buffer_float")?Ae:void 0;break}A!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${Ae}`),this._type=A):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new st(new jn,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new Re(this.width,this.height,I),this._renderTarget.texture.mapping=((x=e.renderTargetOptions)===null||x===void 0?void 0:x.mapping)!==void 0?(w=e.renderTargetOptions)===null||w===void 0?void 0:w.mapping:gn}static instantiateRenderer(){const e=new ns;return e.setSize(128,128),e}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const e=Jr(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,e),e}toDataTexture(e){const n=new Nr(this.toArray(),this.width,this.height,nt,this._type,(e==null?void 0:e.mapping)||gn,(e==null?void 0:e.wrapS)||qe,(e==null?void 0:e.wrapT)||qe,(e==null?void 0:e.magFilter)||xe,(e==null?void 0:e.minFilter)||xe,(e==null?void 0:e.anisotropy)||1,Un);return n.generateMipmaps=(e==null?void 0:e.generateMipmaps)!==void 0?e==null?void 0:e.generateMipmaps:!1,n}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(e){this.disposeOnDemandRenderer(),e&&this.renderTarget.dispose(),this.material instanceof $e&&Object.values(this.material.uniforms).forEach(n=>{n.value instanceof tt&&n.value.dispose()}),Object.values(this.material).forEach(n=>{n instanceof tt&&n.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const Ca=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,Da=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class Ua extends $e{constructor({gamma:e,offsetHdr:n,offsetSdr:r,gainMapMin:i,gainMapMax:s,maxDisplayBoost:a,hdrCapacityMin:o,hdrCapacityMax:l,sdr:c,gainMap:d}){super({name:"GainMapDecoderMaterial",vertexShader:Ca,fragmentShader:Da,uniforms:{sdr:{value:c},gainMap:{value:d},gamma:{value:new Q(1/e[0],1/e[1],1/e[2])},offsetHdr:{value:new Q().fromArray(n)},offsetSdr:{value:new Q().fromArray(r)},gainMapMin:{value:new Q().fromArray(i)},gainMapMax:{value:new Q().fromArray(s)},weightFactor:{value:(Math.log2(a)-o)/(l-o)}},blending:ot,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=a,this._hdrCapacityMin=o,this._hdrCapacityMax=l,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(e){this.uniforms.sdr.value=e}get gainMap(){return this.uniforms.gainMap.value}set gainMap(e){this.uniforms.gainMap.value=e}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(e){this.uniforms.offsetHdr.value.fromArray(e)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(e){this.uniforms.offsetSdr.value.fromArray(e)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(e){this.uniforms.gainMapMin.value.fromArray(e)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(e){this.uniforms.gainMapMax.value.fromArray(e)}get gamma(){const e=this.uniforms.gamma.value;return[1/e.x,1/e.y,1/e.z]}set gamma(e){const n=this.uniforms.gamma.value;n.x=1/e[0],n.y=1/e[1],n.z=1/e[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(e){this._hdrCapacityMin=e,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(e){this._hdrCapacityMax=e,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(e){this._maxDisplayBoost=Math.max(1,Math.min(65504,e)),this.calculateWeight()}calculateWeight(){const e=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,e))}}class ei extends Error{}class ti extends Error{}const qt=(t,e,n)=>{var r;let i;const s=(r=t.attributes.getNamedItem(e))===null||r===void 0?void 0:r.nodeValue;if(s)i=s;else{const a=t.getElementsByTagName(e)[0];if(a){const o=a.getElementsByTagName("rdf:li");if(o.length===3)i=Array.from(o).map(l=>l.innerHTML);else throw new Error(`Gainmap metadata contains an array of items for ${e} but its length is not 3`)}else{if(n)return n;throw new Error(`Can't find ${e} in gainmap metadata`)}}return i},La=t=>{var e,n;let r;typeof TextDecoder<"u"?r=new TextDecoder().decode(t):r=t.toString();let i=r.indexOf("<x:xmpmeta");const s=new DOMParser;for(;i!==-1;){const a=r.indexOf("x:xmpmeta>",i);r.slice(i,a+10);const o=r.slice(i,a+10);try{const c=s.parseFromString(o,"text/xml").getElementsByTagName("rdf:Description")[0],d=qt(c,"hdrgm:GainMapMin","0"),m=qt(c,"hdrgm:GainMapMax"),f=qt(c,"hdrgm:Gamma","1"),p=qt(c,"hdrgm:OffsetSDR","0.015625"),T=qt(c,"hdrgm:OffsetHDR","0.015625");let g=(e=c.attributes.getNamedItem("hdrgm:HDRCapacityMin"))===null||e===void 0?void 0:e.nodeValue;g||(g="0");const x=(n=c.attributes.getNamedItem("hdrgm:HDRCapacityMax"))===null||n===void 0?void 0:n.nodeValue;if(!x)throw new Error("Incomplete gainmap metadata");return{gainMapMin:Array.isArray(d)?d.map(w=>parseFloat(w)):[parseFloat(d),parseFloat(d),parseFloat(d)],gainMapMax:Array.isArray(m)?m.map(w=>parseFloat(w)):[parseFloat(m),parseFloat(m),parseFloat(m)],gamma:Array.isArray(f)?f.map(w=>parseFloat(w)):[parseFloat(f),parseFloat(f),parseFloat(f)],offsetSdr:Array.isArray(p)?p.map(w=>parseFloat(w)):[parseFloat(p),parseFloat(p),parseFloat(p)],offsetHdr:Array.isArray(T)?T.map(w=>parseFloat(w)):[parseFloat(T),parseFloat(T),parseFloat(T)],hdrCapacityMin:parseFloat(g),hdrCapacityMax:parseFloat(x)}}catch{}i=r.indexOf("<x:xmpmeta",a)}};class Pa{constructor(e){this.options={debug:e&&e.debug!==void 0?e.debug:!1,extractFII:e&&e.extractFII!==void 0?e.extractFII:!0,extractNonFII:e&&e.extractNonFII!==void 0?e.extractNonFII:!0}}extract(e){return new Promise((n,r)=>{const i=this.options.debug,s=new DataView(e.buffer);if(s.getUint16(0)!==65496){r(new Error("Not a valid jpeg"));return}const a=s.byteLength;let o=2,l=0,c;for(;o<a;){if(++l>250){r(new Error(`Found no marker after ${l} loops 😵`));return}if(s.getUint8(o)!==255){r(new Error(`Not a valid marker at offset 0x${o.toString(16)}, found: 0x${s.getUint8(o).toString(16)}`));return}if(c=s.getUint8(o+1),i&&console.log(`Marker: ${c.toString(16)}`),c===226){i&&console.log("Found APP2 marker (0xffe2)");const d=o+4;if(s.getUint32(d)===1297106432){const m=d+4;let f;if(s.getUint16(m)===18761)f=!1;else if(s.getUint16(m)===19789)f=!0;else{r(new Error("No valid endianness marker found in TIFF header"));return}if(s.getUint16(m+2,!f)!==42){r(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const p=s.getUint32(m+4,!f);if(p<8){r(new Error("Not valid TIFF data! (First offset less than 8)"));return}const T=m+p,g=s.getUint16(T,!f),x=T+2;let w=0;for(let P=x;P<x+12*g;P+=12)s.getUint16(P,!f)===45057&&(w=s.getUint32(P+8,!f));const A=T+2+g*12+4,R=[];for(let P=A;P<A+w*16;P+=16){const D={MPType:s.getUint32(P,!f),size:s.getUint32(P+4,!f),dataOffset:s.getUint32(P+8,!f),dependantImages:s.getUint32(P+12,!f),start:-1,end:-1,isFII:!1};D.dataOffset?(D.start=m+D.dataOffset,D.isFII=!1):(D.start=0,D.isFII=!0),D.end=D.start+D.size,R.push(D)}if(this.options.extractNonFII&&R.length){const P=new Blob([s]),D=[];for(const U of R){if(U.isFII&&!this.options.extractFII)continue;const E=P.slice(U.start,U.end+1,"image/jpeg");D.push(E)}n(D)}}}o+=2+s.getUint16(o+2)}})}}const Na=async t=>{const e=La(t);if(!e)throw new ti("Gain map XMP metadata not found");const r=await new Pa({extractFII:!0,extractNonFII:!0}).extract(t);if(r.length!==2)throw new ei("Gain map recovery image not found");return{sdr:new Uint8Array(await r[0].arrayBuffer()),gainMap:new Uint8Array(await r[1].arrayBuffer()),metadata:e}},dr=t=>new Promise((e,n)=>{const r=document.createElement("img");r.onload=()=>{e(r)},r.onerror=i=>{n(i)},r.src=URL.createObjectURL(t)});class ni extends Tn{constructor(e,n){super(n),e&&(this._renderer=e),this._internalLoadingManager=new Fr}setRenderer(e){return this._renderer=e,this}setRenderTargetOptions(e){return this._renderTargetOptions=e,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const e=new Ua({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new tt,sdr:new tt});return new Xn({width:16,height:16,type:Le,colorSpace:Un,material:e,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(e,n,r,i){const s=i?new Blob([i],{type:"image/jpeg"}):void 0,a=new Blob([r],{type:"image/jpeg"});let o,l,c=!1;if(typeof createImageBitmap>"u"){const f=await Promise.all([s?dr(s):Promise.resolve(void 0),dr(a)]);l=f[0],o=f[1],c=!0}else{const f=await Promise.all([s?createImageBitmap(s,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(a,{imageOrientation:"flipY"})]);l=f[0],o=f[1]}const d=new tt(l||new ImageData(2,2),gn,qe,qe,xe,fr,nt,Be,1,Un);d.flipY=c,d.needsUpdate=!0;const m=new tt(o,gn,qe,qe,xe,fr,nt,Be,1,Jt);m.flipY=c,m.needsUpdate=!0,e.width=o.width,e.height=o.height,e.material.gainMap=d,e.material.sdr=m,e.material.gainMapMin=n.gainMapMin,e.material.gainMapMax=n.gainMapMax,e.material.offsetHdr=n.offsetHdr,e.material.offsetSdr=n.offsetSdr,e.material.gamma=n.gamma,e.material.hdrCapacityMin=n.hdrCapacityMin,e.material.hdrCapacityMax=n.hdrCapacityMax,e.material.maxDisplayBoost=Math.pow(2,n.hdrCapacityMax),e.material.needsUpdate=!0,e.render()}}class Ba extends ni{load([e,n,r],i,s,a){const o=this.prepareQuadRenderer();let l,c,d;const m=async()=>{if(l&&c&&d){try{await this.render(o,d,l,c)}catch(C){this.manager.itemError(e),this.manager.itemError(n),this.manager.itemError(r),typeof a=="function"&&a(C),o.disposeOnDemandRenderer();return}typeof i=="function"&&i(o),this.manager.itemEnd(e),this.manager.itemEnd(n),this.manager.itemEnd(r),o.disposeOnDemandRenderer()}};let f=!0,p=0,T=0,g=!0,x=0,w=0,I=!0,A=0,R=0;const P=()=>{if(typeof s=="function"){const C=p+x+A,j=T+w+R,Y=f&&g&&I;s(new ProgressEvent("progress",{lengthComputable:Y,loaded:j,total:C}))}};this.manager.itemStart(e),this.manager.itemStart(n),this.manager.itemStart(r);const D=new pt(this._internalLoadingManager);D.setResponseType("arraybuffer"),D.setRequestHeader(this.requestHeader),D.setPath(this.path),D.setWithCredentials(this.withCredentials),D.load(e,async C=>{if(typeof C=="string")throw new Error("Invalid sdr buffer");l=C,await m()},C=>{f=C.lengthComputable,T=C.loaded,p=C.total,P()},C=>{this.manager.itemError(e),typeof a=="function"&&a(C)});const U=new pt(this._internalLoadingManager);U.setResponseType("arraybuffer"),U.setRequestHeader(this.requestHeader),U.setPath(this.path),U.setWithCredentials(this.withCredentials),U.load(n,async C=>{if(typeof C=="string")throw new Error("Invalid gainmap buffer");c=C,await m()},C=>{g=C.lengthComputable,w=C.loaded,x=C.total,P()},C=>{this.manager.itemError(n),typeof a=="function"&&a(C)});const E=new pt(this._internalLoadingManager);return E.setRequestHeader(this.requestHeader),E.setPath(this.path),E.setWithCredentials(this.withCredentials),E.load(r,async C=>{if(typeof C!="string")throw new Error("Invalid metadata string");d=JSON.parse(C),await m()},C=>{I=C.lengthComputable,R=C.loaded,A=C.total,P()},C=>{this.manager.itemError(r),typeof a=="function"&&a(C)}),o}}class Fa extends ni{load(e,n,r,i){const s=this.prepareQuadRenderer(),a=new pt(this._internalLoadingManager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(this.withCredentials),this.manager.itemStart(e),a.load(e,async o=>{if(typeof o=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const l=new Uint8Array(o);let c,d,m;try{const f=await Na(l);c=f.sdr,d=f.gainMap,m=f.metadata}catch(f){if(f instanceof ti||f instanceof ei)console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),m={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},c=l;else throw f}try{await this.render(s,m,c,d)}catch(f){this.manager.itemError(e),typeof i=="function"&&i(f),s.disposeOnDemandRenderer();return}typeof n=="function"&&n(s),this.manager.itemEnd(e),s.disposeOnDemandRenderer()},r,o=>{this.manager.itemError(e),typeof i=="function"&&i(o)}),s}}const rn={apartment:"lebombo_1k.hdr",city:"potsdamer_platz_1k.hdr",dawn:"kiara_1_dawn_1k.hdr",forest:"forest_slope_1k.hdr",lobby:"st_fagans_interior_1k.hdr",night:"dikhololo_night_1k.hdr",park:"rooitou_park_1k.hdr",studio:"studio_small_03_1k.hdr",sunset:"venice_sunset_1k.hdr",warehouse:"empty_warehouse_01_1k.hdr"},ri="https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",Pt=t=>Array.isArray(t),qn=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"];function zt({files:t=qn,path:e="",preset:n=void 0,encoding:r=void 0,extensions:i}={}){let s=null,a=!1;n&&(Yn(n),t=rn[n],e=ri),a=Pt(t);const{extension:o,isCubemap:l}=$n(t);if(s=Qn(o),!s)throw new Error("useEnvironment: Unrecognized file extension: "+t);const c=Ie(p=>p.gl);y.useLayoutEffect(()=>{if(o!=="webp"&&o!=="jpg"&&o!=="jpeg")return;function p(){at.clear(s,a?[t]:t)}c.domElement.addEventListener("webglcontextlost",p,{once:!0})},[t,c.domElement]);const d=at(s,a?[t]:t,p=>{(o==="webp"||o==="jpg"||o==="jpeg")&&p.setRenderer(c),p.setPath==null||p.setPath(e),i&&i(p)});let m=a?d[0]:d;if(o==="jpg"||o==="jpeg"||o==="webp"){var f;m=(f=m.renderTarget)==null?void 0:f.texture}return m.mapping=l?as:os,"colorSpace"in m?m.colorSpace=r??l?"srgb":"srgb-linear":m.encoding=r??l?Vs:Ws,m}const Oa={files:qn,path:"",preset:void 0,extensions:void 0};zt.preload=t=>{const e={...Oa,...t};let{files:n,path:r=""}=e;const{preset:i,extensions:s}=e;i&&(Yn(i),n=rn[i],r=ri);const{extension:a}=$n(n);if(a==="webp"||a==="jpg"||a==="jpeg")throw new Error("useEnvironment: Preloading gainmaps is not supported");const o=Qn(a);if(!o)throw new Error("useEnvironment: Unrecognized file extension: "+n);at.preload(o,Pt(n)?[n]:n,l=>{l.setPath==null||l.setPath(r),s&&s(l)})};const ka={files:qn,preset:void 0};zt.clear=t=>{const e={...ka,...t};let{files:n}=e;const{preset:r}=e;r&&(Yn(r),n=rn[r]);const{extension:i}=$n(n),s=Qn(i);if(!s)throw new Error("useEnvironment: Unrecognized file extension: "+n);at.clear(s,Pt(n)?[n]:n)};function Yn(t){if(!(t in rn))throw new Error("Preset must be one of: "+Object.keys(rn).join(", "))}function $n(t){var e;const n=Pt(t)&&t.length===6,r=Pt(t)&&t.length===3&&t.some(a=>a.endsWith("json")),i=Pt(t)?t[0]:t;return{extension:n?"cube":r?"webp":i.startsWith("data:application/exr")?"exr":i.startsWith("data:application/hdr")?"hdr":i.startsWith("data:image/jpeg")?"jpg":(e=i.split(".").pop())==null||(e=e.split("?"))==null||(e=e.shift())==null?void 0:e.toLowerCase(),isCubemap:n,isGainmap:r}}function Qn(t){return t==="cube"?ls:t==="hdr"?pa:t==="exr"?va:t==="jpg"||t==="jpeg"?Fa:t==="webp"?Ba:null}const za=t=>t.current&&t.current.isScene,Ha=t=>za(t)?t.current:t;function Jn(t,e,n,r,i={}){var s,a,o,l;i={backgroundBlurriness:0,backgroundIntensity:1,backgroundRotation:[0,0,0],environmentIntensity:1,environmentRotation:[0,0,0],...i};const c=Ha(e||n),d=c.background,m=c.environment,f={backgroundBlurriness:c.backgroundBlurriness,backgroundIntensity:c.backgroundIntensity,backgroundRotation:(s=(a=c.backgroundRotation)==null||a.clone==null?void 0:a.clone())!==null&&s!==void 0?s:[0,0,0],environmentIntensity:c.environmentIntensity,environmentRotation:(o=(l=c.environmentRotation)==null||l.clone==null?void 0:l.clone())!==null&&o!==void 0?o:[0,0,0]};return t!=="only"&&(c.environment=r),t&&(c.background=r),Ln(c,i),()=>{t!=="only"&&(c.environment=m),t&&(c.background=d),Ln(c,f)}}function er({scene:t,background:e=!1,map:n,...r}){const i=Ie(s=>s.scene);return y.useLayoutEffect(()=>{if(n)return Jn(e,t,i,n,r)}),null}function ii({background:t=!1,scene:e,blur:n,backgroundBlurriness:r,backgroundIntensity:i,backgroundRotation:s,environmentIntensity:a,environmentRotation:o,...l}){const c=zt(l),d=Ie(m=>m.scene);return y.useLayoutEffect(()=>Jn(t,e,d,c,{backgroundBlurriness:n??r,backgroundIntensity:i,backgroundRotation:s,environmentIntensity:a,environmentRotation:o})),null}function Ga({children:t,near:e=.1,far:n=1e3,resolution:r=256,frames:i=1,map:s,background:a=!1,blur:o,backgroundBlurriness:l,backgroundIntensity:c,backgroundRotation:d,environmentIntensity:m,environmentRotation:f,scene:p,files:T,path:g,preset:x=void 0,extensions:w}){const I=Ie(E=>E.gl),A=Ie(E=>E.scene),R=y.useRef(null),[P]=y.useState(()=>new nn),D=y.useMemo(()=>{const E=new Dr(r);return E.texture.type=Le,E},[r]);y.useLayoutEffect(()=>{if(i===1){const E=I.autoClear;I.autoClear=!0,R.current.update(I,P),I.autoClear=E}return Jn(a,p,A,D.texture,{backgroundBlurriness:o??l,backgroundIntensity:c,backgroundRotation:d,environmentIntensity:m,environmentRotation:f})},[t,P,D.texture,p,A,a,i,I]);let U=1;return Ye(()=>{if(i===1/0||U<i){const E=I.autoClear;I.autoClear=!0,R.current.update(I,P),I.autoClear=E,U++}}),y.createElement(y.Fragment,null,cs(y.createElement(y.Fragment,null,t,y.createElement("cubeCamera",{ref:R,args:[e,n,D]}),T||x?y.createElement(ii,{background:!0,files:T,preset:x,path:g,extensions:w}):s?y.createElement(er,{background:!0,map:s,extensions:w}):null),P))}function ja(t){var e,n,r,i;const s=zt(t),a=t.map||s;y.useMemo(()=>Hn({GroundProjectedEnvImpl:ua}),[]);const o=y.useMemo(()=>[a],[a]),l=(e=t.ground)==null?void 0:e.height,c=(n=t.ground)==null?void 0:n.radius,d=(r=(i=t.ground)==null?void 0:i.scale)!==null&&r!==void 0?r:1e3;return y.createElement(y.Fragment,null,y.createElement(er,dt({},t,{map:a})),y.createElement("groundProjectedEnvImpl",{args:o,scale:d,height:l,radius:c}))}function Va(t){return t.ground?y.createElement(ja,t):t.map?y.createElement(er,t):t.children?y.createElement(Ga,t):y.createElement(ii,t)}const hr=y.forwardRef(({light:t,args:e,map:n,toneMapped:r=!1,color:i="white",form:s="rect",intensity:a=1,scale:o=1,target:l=[0,0,0],children:c,...d},m)=>{const f=y.useRef(null);return y.useImperativeHandle(m,()=>f.current,[]),y.useLayoutEffect(()=>{!c&&!d.material&&(Ln(f.current.material,{color:i}),f.current.material.color.multiplyScalar(a))},[i,a,c,d.material]),y.useLayoutEffect(()=>{d.rotation||f.current.quaternion.identity(),l&&!d.rotation&&(typeof l=="boolean"?f.current.lookAt(0,0,0):f.current.lookAt(Array.isArray(l)?new Q(...l):l))},[l,d.rotation]),o=Array.isArray(o)&&o.length===2?[o[0],o[1],1]:o,y.createElement("mesh",dt({ref:f,scale:o},d),s==="circle"?y.createElement("ringGeometry",{args:e||[0,.5,64]}):s==="ring"?y.createElement("ringGeometry",{args:e||[.25,.5,64]}):s==="rect"||s==="plane"?y.createElement("planeGeometry",{args:e||[1,1]}):s==="box"?y.createElement("boxGeometry",{args:e||[1,1,1]}):y.createElement(s,{args:e}),c||y.createElement("meshBasicMaterial",{toneMapped:r,map:n,side:ht}),t&&y.createElement("pointLight",dt({castShadow:!0},t)))}),le=Object.freeze({SHOWROOM:"ShowRoom",ROAD:"ROAD",TECH:"Tech"}),It=Object.freeze({BLUE:0,SLIVER:1,OTHER:2}),Me=Object.freeze({FLOW:1,LD:2,MEDEA:0}),Ht=y.createContext({sceneType:le.SHOWROOM,carColor:It.BLUE,techType:""});function Wa(){const t=y.useRef(null);y.useState({maxZoom:1/0}),new us().translate(0,2,0),y.useRef(null);const{sceneType:n,techType:r}=y.useContext(Ht),i=Ie();return Ye(s=>{He.update()}),y.useEffect(()=>{const{camera:s}=i;if(t.current&&(n===le.SHOWROOM&&(s.position.set(-13.29,2.59,2.98),t.current.target=new Q(.86,1.36,2.019),t.current.maxDistance=25,t.current.minDistance=8,t.current.minPolarAngle=-Math.PI*.5,t.current.maxPolarAngle=Math.PI*.5,t.current.minAzimuthAngle=-1/0,t.current.maxAzimuthAngle=1/0),n===le.ROAD&&(s.position.set(-13.29,2.59,2.98),t.current.target=new Q(.86,1.36,2.019),t.current.maxZoom=1,t.current.maxDistance=20,t.current.minDistance=8,t.current.minAzimuthAngle=-Math.PI*.5,t.current.maxAzimuthAngle=Math.PI*.5,t.current.minPolarAngle=-Math.PI*.5,t.current.maxPolarAngle=Math.PI*.5),n===le.TECH))switch(r){case Me.MEDEA:s.position.set(-9.58,4.59,26.78),t.current.target=new Q(.86,1.36,2.019),t.current.maxZoom=1,t.current.maxDistance=30,t.current.minDistance=8,t.current.minPolarAngle=-Math.PI*.5,t.current.maxPolarAngle=Math.PI*.5,t.current.minAzimuthAngle=-1/0,t.current.maxAzimuthAngle=1/0;break;case Me.LD:s.position.set(-16.18,12.33,30.54),t.current.target=new Q(.86,1.36,2.019),t.current.maxZoom=1,t.current.maxDistance=40,t.current.minDistance=15,t.current.minAzimuthAngle=-Math.PI*.5,t.current.maxAzimuthAngle=Math.PI*.5,t.current.minPolarAngle=-Math.PI*.5,t.current.maxPolarAngle=Math.PI*.5;break;case Me.FLOW:s.position.set(-9.58,4.59,26.78),t.current.target=new Q(.86,1.36,2.019),t.current.maxZoom=1,t.current.maxDistance=30,t.current.minDistance=8,t.current.minPolarAngle=-Math.PI*.5,t.current.maxPolarAngle=Math.PI*.5,t.current.minAzimuthAngle=-1/0,t.current.maxAzimuthAngle=1/0;break}},[n,r]),_.jsxs(_.Fragment,{children:[_.jsx(Ks,{ref:t,makeDefault:!0}),_.jsx(Va,{files:__VITE_URL__+"/envMap/abstract-lighting-ray-room-style-01_2K_f478fdd1-243a-4cc8-b454-0f522f1afb6b.exr",background:!1})]})}/**
 * postprocessing v6.29.3 build Sun Jan 01 2023
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2023 Raoul van Rüschen
 * @license Zlib
 */var Ka=`#include <packing>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
uniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));
#if __VERSION__ < 300
float l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#else
float l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#endif
l0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}`,tr="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",Za=class extends $e{constructor(){super({name:"AdaptiveLuminanceMaterial",defines:{THREE_REVISION:Ft.replace(/\D+/g,""),MIP_LEVEL_1X1:"0.0"},uniforms:{luminanceBuffer0:new z(null),luminanceBuffer1:new z(null),minLuminance:new z(.01),deltaTime:new z(0),tau:new z(1)},extensions:{shaderTextureLOD:!0},blending:ot,depthWrite:!1,depthTest:!1,fragmentShader:Ka,vertexShader:tr}),this.toneMapped=!1}set luminanceBuffer0(t){this.uniforms.luminanceBuffer0.value=t}setLuminanceBuffer0(t){this.uniforms.luminanceBuffer0.value=t}set luminanceBuffer1(t){this.uniforms.luminanceBuffer1.value=t}setLuminanceBuffer1(t){this.uniforms.luminanceBuffer1.value=t}set mipLevel1x1(t){this.defines.MIP_LEVEL_1X1=t.toFixed(1),this.needsUpdate=!0}setMipLevel1x1(t){this.mipLevel1x1=t}set deltaTime(t){this.uniforms.deltaTime.value=t}setDeltaTime(t){this.uniforms.deltaTime.value=t}get minLuminance(){return this.uniforms.minLuminance.value}set minLuminance(t){this.uniforms.minLuminance.value=t}getMinLuminance(){return this.uniforms.minLuminance.value}setMinLuminance(t){this.uniforms.minLuminance.value=t}get adaptationRate(){return this.uniforms.tau.value}set adaptationRate(t){this.uniforms.tau.value=t}getAdaptationRate(){return this.uniforms.tau.value}setAdaptationRate(t){this.uniforms.tau.value=t}},$={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},Et={NONE:0,DEPTH:1,CONVOLUTION:2},se={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},nr={VERY_SMALL:0,SMALL:1,MEDIUM:2,LARGE:3,VERY_LARGE:4,HUGE:5},Xa={SCALE_UP:"lut.scaleup"},ft={REINHARD:0,REINHARD2:1,REINHARD2_ADAPTIVE:2,OPTIMIZED_CINEON:3,ACES_FILMIC:4},hn={DEFAULT:0,ESKIL:1},qa=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
}`,Ya="uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",$a=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],Qa=class extends $e{constructor(t=new vn){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new z(null),texelSize:new z(new vn),scale:new z(1),kernel:new z(0)},blending:ot,depthWrite:!1,depthTest:!1,fragmentShader:qa,vertexShader:Ya}),this.toneMapped=!1,this.setTexelSize(t.x,t.y),this.kernelSize=nr.MEDIUM}set inputBuffer(t){this.uniforms.inputBuffer.value=t}setInputBuffer(t){this.inputBuffer=t}get kernelSequence(){return $a[this.kernelSize]}get scale(){return this.uniforms.scale.value}set scale(t){this.uniforms.scale.value=t}getScale(){return this.uniforms.scale.value}setScale(t){this.uniforms.scale.value=t}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(t){this.uniforms.kernel.value=t}setKernel(t){this.kernel=t}setTexelSize(t,e){this.uniforms.texelSize.value.set(t,e,t*.5,e*.5)}setSize(t,e){const n=1/t,r=1/e;this.uniforms.texelSize.value.set(n,r,n*.5,r*.5)}},Ja=`#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
#include <dithering_fragment>
}`,si=class extends $e{constructor(){super({name:"CopyMaterial",uniforms:{inputBuffer:new z(null),opacity:new z(1)},blending:ot,depthWrite:!1,depthTest:!1,fragmentShader:Ja,vertexShader:tr}),this.toneMapped=!1}set inputBuffer(t){this.uniforms.inputBuffer.value=t}setInputBuffer(t){this.uniforms.inputBuffer.value=t}getOpacity(t){return this.uniforms.opacity.value}setOpacity(t){this.uniforms.opacity.value=t}},eo=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[]=float[4](abs(c-samples[0]),abs(c-samples[1]),abs(c-samples[2]),abs(c-samples[3]));float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[]=float[4](readDepth(vUv0),readDepth(vUv1),readDepth(vUv2),readDepth(vUv3));int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[]=vec3[4](texture2D(normalBuffer,vUv0).rgb,texture2D(normalBuffer,vUv1).rgb,texture2D(normalBuffer,vUv2).rgb,texture2D(normalBuffer,vUv3).rgb);
#else
vec3 n[]=vec3[4](vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));
#endif
gl_FragColor=vec4(n[index],d[index]);}`,to="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",no=class extends $e{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new z(null),normalBuffer:new z(null),texelSize:new z(new me)},blending:ot,depthWrite:!1,depthTest:!1,fragmentShader:eo,vertexShader:to}),this.toneMapped=!1}set depthBuffer(t){this.uniforms.depthBuffer.value=t}set depthPacking(t){this.defines.DEPTH_PACKING=t.toFixed(0),this.needsUpdate=!0}setDepthBuffer(t,e=kt){this.depthBuffer=t,this.depthPacking=e}set normalBuffer(t){this.uniforms.normalBuffer.value=t,t!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(t){this.normalBuffer=t}setTexelSize(t,e){this.uniforms.texelSize.value.set(t,e)}setSize(t,e){this.uniforms.texelSize.value.set(1/t,1/e)}},ro=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <encodings_fragment>
}`,io="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",so=class extends $e{constructor(){super({name:"DownsamplingMaterial",uniforms:{inputBuffer:new z(null),texelSize:new z(new me)},blending:ot,depthWrite:!1,depthTest:!1,fragmentShader:ro,vertexShader:io}),this.toneMapped=!1}set inputBuffer(t){this.uniforms.inputBuffer.value=t}setSize(t,e){this.uniforms.texelSize.value.set(1/t,1/e)}},ao=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`,oo="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}",lo=class extends $e{constructor(t,e,n,r,i=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:Ft.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new z(null),depthBuffer:new z(null),resolution:new z(new me),texelSize:new z(new me),cameraNear:new z(.3),cameraFar:new z(1e3),aspect:new z(1),time:new z(0)},blending:ot,depthWrite:!1,depthTest:!1,dithering:i}),this.toneMapped=!1,t&&this.setShaderParts(t),e&&this.setDefines(e),n&&this.setUniforms(n),this.copyCameraSettings(r)}set inputBuffer(t){this.uniforms.inputBuffer.value=t}setInputBuffer(t){this.uniforms.inputBuffer.value=t}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(t){this.uniforms.depthBuffer.value=t}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(t){this.defines.DEPTH_PACKING=t.toFixed(0),this.needsUpdate=!0}setDepthBuffer(t,e=kt){this.depthBuffer=t,this.depthPacking=e}setShaderData(t){this.setShaderParts(t.shaderParts),this.setDefines(t.defines),this.setUniforms(t.uniforms),this.setExtensions(t.extensions)}setShaderParts(t){var e,n,r,i,s;return this.fragmentShader=ao.replace(se.FRAGMENT_HEAD,(e=t.get(se.FRAGMENT_HEAD))!=null?e:"").replace(se.FRAGMENT_MAIN_UV,(n=t.get(se.FRAGMENT_MAIN_UV))!=null?n:"").replace(se.FRAGMENT_MAIN_IMAGE,(r=t.get(se.FRAGMENT_MAIN_IMAGE))!=null?r:""),this.vertexShader=oo.replace(se.VERTEX_HEAD,(i=t.get(se.VERTEX_HEAD))!=null?i:"").replace(se.VERTEX_MAIN_SUPPORT,(s=t.get(se.VERTEX_MAIN_SUPPORT))!=null?s:""),this.needsUpdate=!0,this}setDefines(t){for(const e of t.entries())this.defines[e[0]]=e[1];return this.needsUpdate=!0,this}setUniforms(t){for(const e of t.entries())this.uniforms[e[0]]=e[1];return this}setExtensions(t){this.extensions={};for(const e of t)this.extensions[e]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(t){this.encodeOutput!==t&&(t?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(t){return this.encodeOutput}setOutputEncodingEnabled(t){this.encodeOutput=t}get time(){return this.uniforms.time.value}set time(t){this.uniforms.time.value=t}setDeltaTime(t){this.uniforms.time.value+=t}adoptCameraSettings(t){this.copyCameraSettings(t)}copyCameraSettings(t){t&&(this.uniforms.cameraNear.value=t.near,this.uniforms.cameraFar.value=t.far,t instanceof Gn?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(t,e){const n=this.uniforms;n.resolution.value.set(t,e),n.texelSize.value.set(1/t,1/e),n.aspect.value=t/e}static get Section(){return se}},co=`#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`,uo=class extends $e{constructor(t=!1,e=null){super({name:"LuminanceMaterial",defines:{THREE_REVISION:Ft.replace(/\D+/g,"")},uniforms:{inputBuffer:new z(null),threshold:new z(0),smoothing:new z(1),range:new z(null)},blending:ot,depthWrite:!1,depthTest:!1,fragmentShader:co,vertexShader:tr}),this.toneMapped=!1,this.colorOutput=t,this.luminanceRange=e}set inputBuffer(t){this.uniforms.inputBuffer.value=t}setInputBuffer(t){this.uniforms.inputBuffer.value=t}get threshold(){return this.uniforms.threshold.value}set threshold(t){this.smoothing>0||t>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=t}getThreshold(){return this.threshold}setThreshold(t){this.threshold=t}get smoothing(){return this.uniforms.smoothing.value}set smoothing(t){this.threshold>0||t>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=t}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(t){this.smoothing=t}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(t){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(t){t?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(t){return this.colorOutput}setColorOutputEnabled(t){this.colorOutput=t}get useRange(){return this.luminanceRange!==null}set useRange(t){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(t){t!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=t,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(t){this.luminanceRange=t}},fo=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <encodings_fragment>
}`,ho="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",mo=class extends $e{constructor(){super({name:"UpsamplingMaterial",uniforms:{inputBuffer:new z(null),supportBuffer:new z(null),texelSize:new z(new me),radius:new z(.85)},blending:ot,depthWrite:!1,depthTest:!1,fragmentShader:fo,vertexShader:ho}),this.toneMapped=!1}set inputBuffer(t){this.uniforms.inputBuffer.value=t}set supportBuffer(t){this.uniforms.supportBuffer.value=t}get radius(){return this.uniforms.radius.value}set radius(t){this.uniforms.radius.value=t}setSize(t,e){this.uniforms.texelSize.value.set(1/t,1/e)}},po=new Ur,wt=null;function vo(){if(wt===null){const t=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),e=new Float32Array([0,0,2,0,0,2]);wt=new Ot,wt.setAttribute!==void 0?(wt.setAttribute("position",new be(t,3)),wt.setAttribute("uv",new be(e,2))):(wt.addAttribute("position",new be(t,3)),wt.addAttribute("uv",new be(e,2)))}return wt}var Ge=class{constructor(t="Pass",e=new nn,n=po){this.name=t,this.renderer=null,this.scene=e,this.camera=n,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(t){if(this.rtt===t){const e=this.fullscreenMaterial;e!==null&&(e.needsUpdate=!0),this.rtt=!t}}set mainScene(t){}set mainCamera(t){}setRenderer(t){this.renderer=t}isEnabled(){return this.enabled}setEnabled(t){this.enabled=t}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(t){let e=this.screen;e!==null?e.material=t:(e=new st(vo(),t),e.frustumCulled=!1,this.scene===null&&(this.scene=new nn),this.scene.add(e),this.screen=e)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(t){this.fullscreenMaterial=t}getDepthTexture(){return null}setDepthTexture(t,e=kt){}render(t,e,n,r,i){throw new Error("Render method not implemented!")}setSize(t,e){}initialize(t,e,n){}dispose(){for(const t of Object.keys(this)){const e=this[t];(e instanceof Re||e instanceof en||e instanceof tt||e instanceof Ge)&&this[t].dispose()}}},ai=class extends Ge{constructor(t,e=!0){super("CopyPass"),this.fullscreenMaterial=new si,this.needsSwap=!1,this.renderTarget=t,t===void 0&&(this.renderTarget=new Re(1,1,{minFilter:xe,magFilter:xe,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=e}get resize(){return this.autoResize}set resize(t){this.autoResize=t}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(t){this.autoResize=t}render(t,e,n,r,i){this.fullscreenMaterial.inputBuffer=e.texture,t.setRenderTarget(this.renderToScreen?null:this.renderTarget),t.render(this.scene,this.camera)}setSize(t,e){this.autoResize&&this.renderTarget.setSize(t,e)}initialize(t,e,n){n!==void 0&&(this.renderTarget.texture.type=n,n!==Be?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":t.outputEncoding===Se&&(this.renderTarget.texture.encoding=Se))}},go=class extends Ge{constructor(t,{minLuminance:e=.01,adaptationRate:n=1}={}){super("AdaptiveLuminancePass"),this.fullscreenMaterial=new Za,this.needsSwap=!1,this.renderTargetPrevious=new Re(1,1,{minFilter:Ct,magFilter:Ct,depthBuffer:!1}),this.renderTargetPrevious.texture.name="Luminance.Previous";const r=this.fullscreenMaterial;r.luminanceBuffer0=this.renderTargetPrevious.texture,r.luminanceBuffer1=t,r.minLuminance=e,r.adaptationRate=n,this.renderTargetAdapted=this.renderTargetPrevious.clone(),this.renderTargetAdapted.texture.name="Luminance.Adapted",this.copyPass=new ai(this.renderTargetPrevious,!1)}get texture(){return this.renderTargetAdapted.texture}getTexture(){return this.renderTargetAdapted.texture}set mipLevel1x1(t){this.fullscreenMaterial.mipLevel1x1=t}get adaptationRate(){return this.fullscreenMaterial.adaptationRate}set adaptationRate(t){this.fullscreenMaterial.adaptationRate=t}render(t,e,n,r,i){this.fullscreenMaterial.deltaTime=r,t.setRenderTarget(this.renderToScreen?null:this.renderTargetAdapted),t.render(this.scene,this.camera),this.copyPass.render(t,this.renderTargetAdapted)}},xo=class extends Ge{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(t,e,n,r,i){const s=t.state.buffers.stencil;s.setLocked(!1),s.setTest(!1)}},mr=new Fe,oi=class extends Ge{constructor(t=!0,e=!0,n=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=t,this.depth=e,this.stencil=n,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(t,e,n){this.color=t,this.depth=e,this.stencil=n}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(t){this.overrideClearColor=t}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(t){this.overrideClearAlpha=t}render(t,e,n,r,i){const s=this.overrideClearColor,a=this.overrideClearAlpha,o=t.getClearAlpha(),l=s!==null,c=a>=0;l?(t.getClearColor(mr),t.setClearColor(s,c?a:o)):c&&t.setClearAlpha(a),t.setRenderTarget(this.renderToScreen?null:e),t.clear(this.color,this.depth,this.stencil),l?t.setClearColor(mr,o):c&&t.setClearAlpha(o)}},Tt=-1,Pe=class extends Vn{constructor(t,e=Tt,n=Tt,r=1){super(),this.resizable=t,this.baseSize=new me(1,1),this.preferredSize=new me(e,n),this.target=this.preferredSize,this.s=r,this.effectiveSize=new me,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const t=this.baseSize,e=this.preferredSize,n=this.effectiveSize,r=this.scale;e.width!==Tt?n.width=e.width:e.height!==Tt?n.width=Math.round(e.height*(t.width/Math.max(t.height,1))):n.width=Math.round(t.width*r),e.height!==Tt?n.height=e.height:e.width!==Tt?n.height=Math.round(e.width/Math.max(t.width/Math.max(t.height,1),1)):n.height=Math.round(t.height*r)}get width(){return this.effectiveSize.width}set width(t){this.preferredWidth=t}get height(){return this.effectiveSize.height}set height(t){this.preferredHeight=t}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(t){this.s!==t&&(this.s=t,this.preferredSize.setScalar(Tt),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(t){this.scale=t}get baseWidth(){return this.baseSize.width}set baseWidth(t){this.baseSize.width!==t&&(this.baseSize.width=t,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(t){this.baseWidth=t}get baseHeight(){return this.baseSize.height}set baseHeight(t){this.baseSize.height!==t&&(this.baseSize.height=t,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(t){this.baseHeight=t}setBaseSize(t,e){(this.baseSize.width!==t||this.baseSize.height!==e)&&(this.baseSize.set(t,e),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(t){this.preferredSize.width!==t&&(this.preferredSize.width=t,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(t){this.preferredWidth=t}get preferredHeight(){return this.preferredSize.height}set preferredHeight(t){this.preferredSize.height!==t&&(this.preferredSize.height=t,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(t){this.preferredHeight=t}setPreferredSize(t,e){(this.preferredSize.width!==t||this.preferredSize.height!==e)&&(this.preferredSize.set(t,e),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(t){this.s=t.scale,this.baseSize.set(t.baseWidth,t.baseHeight),this.preferredSize.set(t.preferredWidth,t.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return Tt}},bn=!1,pr=class{constructor(t=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(t),this.meshCount=0,this.replaceMaterial=e=>{if(e.isMesh){let n;if(e.material.flatShading)switch(e.material.side){case ht:n=this.materialsFlatShadedDoubleSide;break;case un:n=this.materialsFlatShadedBackSide;break;default:n=this.materialsFlatShaded;break}else switch(e.material.side){case ht:n=this.materialsDoubleSide;break;case un:n=this.materialsBackSide;break;default:n=this.materials;break}this.originalMaterials.set(e,e.material),e.isSkinnedMesh?e.material=n[2]:e.isInstancedMesh?e.material=n[1]:e.material=n[0],++this.meshCount}}}setMaterial(t){if(this.disposeMaterials(),this.material=t,t!==null){const e=this.materials=[t.clone(),t.clone(),t.clone()];for(const n of e)n.uniforms=Object.assign({},t.uniforms),n.side=Or;e[2].skinning=!0,this.materialsBackSide=e.map(n=>{const r=n.clone();return r.uniforms=Object.assign({},t.uniforms),r.side=un,r}),this.materialsDoubleSide=e.map(n=>{const r=n.clone();return r.uniforms=Object.assign({},t.uniforms),r.side=ht,r}),this.materialsFlatShaded=e.map(n=>{const r=n.clone();return r.uniforms=Object.assign({},t.uniforms),r.flatShading=!0,r}),this.materialsFlatShadedBackSide=e.map(n=>{const r=n.clone();return r.uniforms=Object.assign({},t.uniforms),r.flatShading=!0,r.side=un,r}),this.materialsFlatShadedDoubleSide=e.map(n=>{const r=n.clone();return r.uniforms=Object.assign({},t.uniforms),r.flatShading=!0,r.side=ht,r})}}render(t,e,n){const r=t.shadowMap.enabled;if(t.shadowMap.enabled=!1,bn){const i=this.originalMaterials;this.meshCount=0,e.traverse(this.replaceMaterial),t.render(e,n);for(const s of i)s[0].material=s[1];this.meshCount!==i.size&&i.clear()}else{const i=e.overrideMaterial;e.overrideMaterial=this.material,t.render(e,n),e.overrideMaterial=i}t.shadowMap.enabled=r}disposeMaterials(){if(this.material!==null){const t=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const e of t)e.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return bn}static set workaroundEnabled(t){bn=t}},li=class extends Ge{constructor(t,e,n=null){super("RenderPass",t,e),this.needsSwap=!1,this.clearPass=new oi,this.overrideMaterialManager=n===null?null:new pr(n),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(t){this.scene=t}set mainCamera(t){this.camera=t}get renderToScreen(){return super.renderToScreen}set renderToScreen(t){super.renderToScreen=t,this.clearPass.renderToScreen=t}get overrideMaterial(){const t=this.overrideMaterialManager;return t!==null?t.material:null}set overrideMaterial(t){const e=this.overrideMaterialManager;t!==null?e!==null?e.setMaterial(t):this.overrideMaterialManager=new pr(t):e!==null&&(e.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(t){this.overrideMaterial=t}get clear(){return this.clearPass.enabled}set clear(t){this.clearPass.enabled=t}getSelection(){return this.selection}setSelection(t){this.selection=t}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(t){this.ignoreBackground=t}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(t){this.skipShadowMapUpdate=t}getClearPass(){return this.clearPass}render(t,e,n,r,i){const s=this.scene,a=this.camera,o=this.selection,l=a.layers.mask,c=s.background,d=t.shadowMap.autoUpdate,m=this.renderToScreen?null:e;o!==null&&a.layers.set(o.getLayer()),this.skipShadowMapUpdate&&(t.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(s.background=null),this.clearPass.enabled&&this.clearPass.render(t,e),t.setRenderTarget(m),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(t,s,a):t.render(s,a),a.layers.mask=l,s.background=c,t.shadowMap.autoUpdate=d}},wo=class extends Ge{constructor({normalBuffer:t=null,resolutionScale:e=.5,width:n=Pe.AUTO_SIZE,height:r=Pe.AUTO_SIZE,resolutionX:i=n,resolutionY:s=r}={}){super("DepthDownsamplingPass");const a=new no;a.normalBuffer=t,this.fullscreenMaterial=a,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new Re(1,1,{minFilter:Ct,magFilter:Ct,depthBuffer:!1,type:Ae}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const o=this.resolution=new Pe(this,i,s,e);o.addEventListener("change",l=>this.setSize(o.baseWidth,o.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(t,e=kt){this.fullscreenMaterial.depthBuffer=t,this.fullscreenMaterial.depthPacking=e}render(t,e,n,r,i){t.setRenderTarget(this.renderToScreen?null:this.renderTarget),t.render(this.scene,this.camera)}setSize(t,e){const n=this.resolution;n.setBaseSize(t,e),this.renderTarget.setSize(n.width,n.height),this.fullscreenMaterial.setSize(t,e)}initialize(t,e,n){const r=t.getContext();if(!(r.getExtension("EXT_color_buffer_float")||r.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}};function vr(t,e,n){for(const r of e){const i="$1"+t+r.charAt(0).toUpperCase()+r.slice(1),s=new RegExp("([^\\.])(\\b"+r+"\\b)","g");for(const a of n.entries())a[1]!==null&&n.set(a[0],a[1].replace(s,i))}}function To(t,e,n){var r,i,s,a,o;let l=e.getFragmentShader(),c=e.getVertexShader();const d=l!==void 0&&/mainImage/.test(l),m=l!==void 0&&/mainUv/.test(l);if(n.attributes|=e.getAttributes(),l===void 0)throw new Error(`Missing fragment shader (${e.name})`);if(m&&n.attributes&Et.CONVOLUTION)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);if(!d&&!m)throw new Error(`Could not find mainImage or mainUv function (${e.name})`);{const f=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,p=n.shaderParts;let T=(r=p.get(se.FRAGMENT_HEAD))!=null?r:"",g=(i=p.get(se.FRAGMENT_MAIN_UV))!=null?i:"",x=(s=p.get(se.FRAGMENT_MAIN_IMAGE))!=null?s:"",w=(a=p.get(se.VERTEX_HEAD))!=null?a:"",I=(o=p.get(se.VERTEX_MAIN_SUPPORT))!=null?o:"";const A=new Set,R=new Set;if(m&&(g+=`	${t}MainUv(UV);
`,n.uvTransformation=!0),c!==null&&/mainSupport/.test(c)){const U=/mainSupport *\([\w\s]*?uv\s*?\)/.test(c);I+=`	${t}MainSupport(`,I+=U?`vUv);
`:`);
`;for(const E of c.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const C of E[1].split(/\s*,\s*/))n.varyings.add(C),A.add(C),R.add(C);for(const E of c.matchAll(f))R.add(E[1])}for(const U of l.matchAll(f))R.add(U[1]);for(const U of e.defines.keys())R.add(U.replace(/\([\w\s,]*\)/g,""));for(const U of e.uniforms.keys())R.add(U);R.delete("while"),R.delete("for"),R.delete("if"),e.uniforms.forEach((U,E)=>n.uniforms.set(t+E.charAt(0).toUpperCase()+E.slice(1),U)),e.defines.forEach((U,E)=>n.defines.set(t+E.charAt(0).toUpperCase()+E.slice(1),U));const P=new Map([["fragment",l],["vertex",c]]);vr(t,R,n.defines),vr(t,R,P),l=P.get("fragment"),c=P.get("vertex");const D=e.blendMode;if(n.blendModes.set(D.blendFunction,D),d){e.inputColorSpace!==null&&e.inputColorSpace!==n.colorSpace&&(x+=e.inputColorSpace===Se?`color0 = LinearTosRGB(color0);
	`:`color0 = sRGBToLinear(color0);
	`),e.outputColorSpace!==null?n.colorSpace=e.outputColorSpace:e.inputColorSpace!==null&&(n.colorSpace=e.inputColorSpace);const U=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;x+=`${t}MainImage(color0, UV, `,n.attributes&Et.DEPTH&&U.test(l)&&(x+="depth, ",n.readDepth=!0),x+=`color1);
	`;const E=t+"BlendOpacity";n.uniforms.set(E,D.opacity),x+=`color0 = blend${D.blendFunction}(color0, color1, ${E});

	`,T+=`uniform float ${E};

`}if(T+=l+`
`,c!==null&&(w+=c+`
`),p.set(se.FRAGMENT_HEAD,T),p.set(se.FRAGMENT_MAIN_UV,g),p.set(se.FRAGMENT_MAIN_IMAGE,x),p.set(se.VERTEX_HEAD,w),p.set(se.VERTEX_MAIN_SUPPORT,I),e.extensions!==null)for(const U of e.extensions)n.extensions.add(U)}}var yo=class extends Ge{constructor(t,...e){super("EffectPass"),this.fullscreenMaterial=new lo(null,null,null,t),this.listener=n=>this.handleEvent(n),this.effects=[],this.setEffects(e),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(t){for(const e of this.effects)e.mainScene=t}set mainCamera(t){this.fullscreenMaterial.copyCameraSettings(t);for(const e of this.effects)e.mainCamera=t}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(t){this.fullscreenMaterial.encodeOutput=t}get dithering(){return this.fullscreenMaterial.dithering}set dithering(t){const e=this.fullscreenMaterial;e.dithering=t,e.needsUpdate=!0}setEffects(t){for(const e of this.effects)e.removeEventListener("change",this.listener);this.effects=t.sort((e,n)=>n.attributes-e.attributes);for(const e of this.effects)e.addEventListener("change",this.listener)}updateMaterial(){const t=new Io;let e=0;for(const a of this.effects)if(a.blendMode.blendFunction===$.DST)t.attributes|=a.getAttributes()&Et.DEPTH;else{if(t.attributes&a.getAttributes()&Et.CONVOLUTION)throw new Error(`Convolution effects cannot be merged (${a.name})`);To("e"+e++,a,t)}let n=t.shaderParts.get(se.FRAGMENT_HEAD),r=t.shaderParts.get(se.FRAGMENT_MAIN_IMAGE),i=t.shaderParts.get(se.FRAGMENT_MAIN_UV);const s=/\bblend\b/g;for(const a of t.blendModes.values())n+=a.getShaderCode().replace(s,`blend${a.blendFunction}`)+`
`;t.attributes&Et.DEPTH?(t.readDepth&&(r=`float depth = readDepth(UV);

	`+r),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,t.colorSpace===Se&&(r+=`color0 = sRGBToLinear(color0);
	`),t.uvTransformation?(i=`vec2 transformedUv = vUv;
`+i,t.defines.set("UV","transformedUv")):t.defines.set("UV","vUv"),t.shaderParts.set(se.FRAGMENT_HEAD,n),t.shaderParts.set(se.FRAGMENT_MAIN_IMAGE,r),t.shaderParts.set(se.FRAGMENT_MAIN_UV,i),t.shaderParts.forEach((a,o,l)=>l.set(o,a==null?void 0:a.trim().replace(/^#/,`
#`))),this.skipRendering=e===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(t)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(t,e=kt){this.fullscreenMaterial.depthBuffer=t,this.fullscreenMaterial.depthPacking=e;for(const n of this.effects)n.setDepthTexture(t,e)}render(t,e,n,r,i){for(const s of this.effects)s.update(t,e,r);if(!this.skipRendering||this.renderToScreen){const s=this.fullscreenMaterial;s.inputBuffer=e.texture,s.time+=r*this.timeScale,t.setRenderTarget(this.renderToScreen?null:n),t.render(this.scene,this.camera)}}setSize(t,e){this.fullscreenMaterial.setSize(t,e);for(const n of this.effects)n.setSize(t,e)}initialize(t,e,n){this.renderer=t;for(const r of this.effects)r.initialize(t,e,n);this.updateMaterial(),n!==void 0&&n!==Be&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const t of this.effects)t.removeEventListener("change",this.listener),t.dispose()}handleEvent(t){switch(t.type){case"change":this.recompile();break}}},So=class extends Ge{constructor({kernelSize:t=nr.MEDIUM,resolutionScale:e=.5,width:n=Pe.AUTO_SIZE,height:r=Pe.AUTO_SIZE,resolutionX:i=n,resolutionY:s=r}={}){super("KawaseBlurPass"),this.renderTargetA=new Re(1,1,{depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";const a=this.resolution=new Pe(this,i,s,e);a.addEventListener("change",o=>this.setSize(a.baseWidth,a.baseHeight)),this._blurMaterial=new Qa,this._blurMaterial.kernelSize=t,this.copyMaterial=new si}getResolution(){return this.resolution}get blurMaterial(){return this._blurMaterial}set blurMaterial(t){this._blurMaterial=t}get dithering(){return this.copyMaterial.dithering}set dithering(t){this.copyMaterial.dithering=t}get kernelSize(){return this.blurMaterial.kernelSize}set kernelSize(t){this.blurMaterial.kernelSize=t}get width(){return this.resolution.width}set width(t){this.resolution.preferredWidth=t}get height(){return this.resolution.height}set height(t){this.resolution.preferredHeight=t}get scale(){return this.blurMaterial.scale}set scale(t){this.blurMaterial.scale=t}getScale(){return this.blurMaterial.scale}setScale(t){this.blurMaterial.scale=t}getKernelSize(){return this.kernelSize}setKernelSize(t){this.kernelSize=t}getResolutionScale(){return this.resolution.scale}setResolutionScale(t){this.resolution.scale=t}render(t,e,n,r,i){const s=this.scene,a=this.camera,o=this.renderTargetA,l=this.renderTargetB,c=this.blurMaterial,d=c.kernelSequence;let m=e;this.fullscreenMaterial=c;for(let f=0,p=d.length;f<p;++f){const T=f&1?l:o;c.kernel=d[f],c.inputBuffer=m.texture,t.setRenderTarget(T),t.render(s,a),m=T}this.fullscreenMaterial=this.copyMaterial,this.copyMaterial.inputBuffer=m.texture,t.setRenderTarget(this.renderToScreen?null:n),t.render(s,a)}setSize(t,e){const n=this.resolution;n.setBaseSize(t,e);const r=n.width,i=n.height;this.renderTargetA.setSize(r,i),this.renderTargetB.setSize(r,i),this.blurMaterial.setSize(t,e)}initialize(t,e,n){n!==void 0&&(this.renderTargetA.texture.type=n,this.renderTargetB.texture.type=n,n!==Be?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):t.outputEncoding===Se&&(this.renderTargetA.texture.encoding=Se,this.renderTargetB.texture.encoding=Se))}static get AUTO_SIZE(){return Pe.AUTO_SIZE}},ci=class extends Ge{constructor({renderTarget:t,luminanceRange:e,colorOutput:n,resolutionScale:r=1,width:i=Pe.AUTO_SIZE,height:s=Pe.AUTO_SIZE,resolutionX:a=i,resolutionY:o=s}={}){super("LuminancePass"),this.fullscreenMaterial=new uo(n,e),this.needsSwap=!1,this.renderTarget=t,this.renderTarget===void 0&&(this.renderTarget=new Re(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target");const l=this.resolution=new Pe(this,a,o,r);l.addEventListener("change",c=>this.setSize(l.baseWidth,l.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(t,e,n,r,i){const s=this.fullscreenMaterial;s.inputBuffer=e.texture,t.setRenderTarget(this.renderToScreen?null:this.renderTarget),t.render(this.scene,this.camera)}setSize(t,e){const n=this.resolution;n.setBaseSize(t,e),this.renderTarget.setSize(n.width,n.height)}initialize(t,e,n){n!==void 0&&n!==Be&&(this.renderTarget.texture.type=n,this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},_o=class extends Ge{constructor(t,e){super("MaskPass",t,e),this.needsSwap=!1,this.clearPass=new oi(!1,!1,!0),this.inverse=!1}set mainScene(t){this.scene=t}set mainCamera(t){this.camera=t}get inverted(){return this.inverse}set inverted(t){this.inverse=t}get clear(){return this.clearPass.enabled}set clear(t){this.clearPass.enabled=t}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(t){this.inverted=t}render(t,e,n,r,i){const s=t.getContext(),a=t.state.buffers,o=this.scene,l=this.camera,c=this.clearPass,d=this.inverted?0:1,m=1-d;a.color.setMask(!1),a.depth.setMask(!1),a.color.setLocked(!0),a.depth.setLocked(!0),a.stencil.setTest(!0),a.stencil.setOp(s.REPLACE,s.REPLACE,s.REPLACE),a.stencil.setFunc(s.ALWAYS,d,4294967295),a.stencil.setClear(m),a.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?c.render(t,null):(c.render(t,e),c.render(t,n))),this.renderToScreen?(t.setRenderTarget(null),t.render(o,l)):(t.setRenderTarget(e),t.render(o,l),t.setRenderTarget(n),t.render(o,l)),a.color.setLocked(!1),a.depth.setLocked(!1),a.stencil.setLocked(!1),a.stencil.setFunc(s.EQUAL,1,4294967295),a.stencil.setOp(s.KEEP,s.KEEP,s.KEEP),a.stencil.setLocked(!0)}},Eo=class extends Ge{constructor(){super("MipmapBlurPass"),this.needsSwap=!1,this.renderTarget=new Re(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Upsampling.Mipmap0",this.downsamplingMipmaps=[],this.upsamplingMipmaps=[],this.downsamplingMaterial=new so,this.upsamplingMaterial=new mo,this.resolution=new me}get texture(){return this.renderTarget.texture}get levels(){return this.downsamplingMipmaps.length}set levels(t){if(this.levels!==t){const e=this.renderTarget;this.dispose(),this.downsamplingMipmaps=[],this.upsamplingMipmaps=[];for(let n=0;n<t;++n){const r=e.clone();r.texture.name="Downsampling.Mipmap"+n,this.downsamplingMipmaps.push(r)}this.upsamplingMipmaps.push(e);for(let n=1,r=t-1;n<r;++n){const i=e.clone();i.texture.name="Upsampling.Mipmap"+n,this.upsamplingMipmaps.push(i)}this.setSize(this.resolution.x,this.resolution.y)}}get radius(){return this.upsamplingMaterial.radius}set radius(t){this.upsamplingMaterial.radius=t}render(t,e,n,r,i){const{scene:s,camera:a}=this,{downsamplingMaterial:o,upsamplingMaterial:l}=this,{downsamplingMipmaps:c,upsamplingMipmaps:d}=this;let m=e;this.fullscreenMaterial=o;for(let f=0,p=c.length;f<p;++f){const T=c[f];o.setSize(m.width,m.height),o.inputBuffer=m.texture,t.setRenderTarget(T),t.render(s,a),m=T}this.fullscreenMaterial=l;for(let f=d.length-1;f>=0;--f){const p=d[f];l.setSize(m.width,m.height),l.inputBuffer=m.texture,l.supportBuffer=c[f].texture,t.setRenderTarget(p),t.render(s,a),m=p}}setSize(t,e){const n=this.resolution;n.set(t,e);let r=n.width,i=n.height;for(let s=0,a=this.downsamplingMipmaps.length;s<a;++s)r=Math.round(r*.5),i=Math.round(i*.5),this.downsamplingMipmaps[s].setSize(r,i),s<this.upsamplingMipmaps.length&&this.upsamplingMipmaps[s].setSize(r,i)}initialize(t,e,n){if(n!==void 0){const r=this.downsamplingMipmaps.concat(this.upsamplingMipmaps);for(const i of r)i.texture.type=n;if(n!==Be)this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1";else if(t.outputEncoding===Se)for(const i of r)i.texture.encoding=Se}}dispose(){super.dispose();for(const t of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))t.dispose()}},Mo=class extends Ge{constructor(t,e,{renderTarget:n,resolutionScale:r=1,width:i=Pe.AUTO_SIZE,height:s=Pe.AUTO_SIZE,resolutionX:a=i,resolutionY:o=s}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new li(t,e,new fs);const l=this.renderPass;l.ignoreBackground=!0,l.skipShadowMapUpdate=!0;const c=l.getClearPass();c.overrideClearColor=new Fe(7829503),c.overrideClearAlpha=1,this.renderTarget=n,this.renderTarget===void 0&&(this.renderTarget=new Re(1,1,{minFilter:Ct,magFilter:Ct}),this.renderTarget.texture.name="NormalPass.Target");const d=this.resolution=new Pe(this,a,o,r);d.addEventListener("change",m=>this.setSize(d.baseWidth,d.baseHeight))}set mainScene(t){this.renderPass.mainScene=t}set mainCamera(t){this.renderPass.mainCamera=t}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(t){this.resolution.scale=t}render(t,e,n,r,i){const s=this.renderToScreen?null:this.renderTarget;this.renderPass.render(t,s,s)}setSize(t,e){const n=this.resolution;n.setBaseSize(t,e),this.renderTarget.setSize(n.width,n.height)}},Rn=1/1e3,bo=1e3,Ro=class{constructor(){this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(t){typeof document<"u"&&document.hidden!==void 0&&(t?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=t)}get delta(){return this._delta*Rn}get fixedDelta(){return this._fixedDelta*Rn}set fixedDelta(t){this._fixedDelta=t*bo}get elapsed(){return this._elapsed*Rn}update(t){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=t!==void 0?t:performance.now(),this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()}handleEvent(t){document.hidden||(this.currentTime=performance.now())}dispose(){this.autoReset=!1}},Ao=class{constructor(e=null,{depthBuffer:n=!0,stencilBuffer:r=!1,multisampling:i=0,frameBufferType:s}={}){this.renderer=null,this.inputBuffer=this.createBuffer(n,r,s,i),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new ai,this.depthTexture=null,this.passes=[],this.timer=new Ro,this.autoRenderToScreen=!0,this.setRenderer(e)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(e){const n=this.inputBuffer,r=this.multisampling;r>0&&e>0?(this.inputBuffer.samples=e,this.outputBuffer.samples=e,this.inputBuffer.dispose(),this.outputBuffer.dispose()):r!==e&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(n.depthBuffer,n.stencilBuffer,n.texture.type,e),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(e){if(this.renderer=e,e!==null){const n=e.getSize(new me),r=e.getContext().getContextAttributes().alpha,i=this.inputBuffer.texture.type;i===Be&&e.outputEncoding===Se&&(this.inputBuffer.texture.encoding=Se,this.outputBuffer.texture.encoding=Se,this.inputBuffer.dispose(),this.outputBuffer.dispose()),e.autoClear=!1,this.setSize(n.width,n.height);for(const s of this.passes)s.initialize(e,r,i)}}replaceRenderer(e,n=!0){const r=this.renderer,i=r.domElement.parentNode;return this.setRenderer(e),n&&i!==null&&(i.removeChild(r.domElement),i.appendChild(e.domElement)),r}createDepthTexture(){const e=this.depthTexture=new Lr;return this.inputBuffer.depthTexture=e,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(e.format=ds,e.type=hs):e.type=Br,e}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const e of this.passes)e.setDepthTexture(null)}}createBuffer(e,n,r,i){const s=this.renderer,a=s===null?new me:s.getDrawingBufferSize(new me),o={minFilter:xe,magFilter:xe,stencilBuffer:n,depthBuffer:e,type:r};let l;return i>0?(l=Number(Ft.replace(/\D+/g,""))<138?new ms(a.width,a.height,o):new Re(a.width,a.height,o),l.ignoreDepthForMultisampleCopy=!1,l.samples=i):l=new Re(a.width,a.height,o),r===Be&&s!==null&&s.outputEncoding===Se&&(l.texture.encoding=Se),l.texture.name="EffectComposer.Buffer",l.texture.generateMipmaps=!1,l}setMainScene(e){for(const n of this.passes)n.mainScene=e}setMainCamera(e){for(const n of this.passes)n.mainCamera=e}addPass(e,n){const r=this.passes,i=this.renderer,s=i.getDrawingBufferSize(new me),a=i.getContext().getContextAttributes().alpha,o=this.inputBuffer.texture.type;if(e.setRenderer(i),e.setSize(s.width,s.height),e.initialize(i,a,o),this.autoRenderToScreen&&(r.length>0&&(r[r.length-1].renderToScreen=!1),e.renderToScreen&&(this.autoRenderToScreen=!1)),n!==void 0?r.splice(n,0,e):r.push(e),this.autoRenderToScreen&&(r[r.length-1].renderToScreen=!0),e.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const l=this.createDepthTexture();for(e of r)e.setDepthTexture(l)}else e.setDepthTexture(this.depthTexture)}removePass(e){const n=this.passes,r=n.indexOf(e);if(r!==-1&&n.splice(r,1).length>0){if(this.depthTexture!==null){const a=(l,c)=>l||c.needsDepthTexture;n.reduce(a,!1)||(e.getDepthTexture()===this.depthTexture&&e.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&r===n.length&&(e.renderToScreen=!1,n.length>0&&(n[n.length-1].renderToScreen=!0))}}removeAllPasses(){const e=this.passes;this.deleteDepthTexture(),e.length>0&&(this.autoRenderToScreen&&(e[e.length-1].renderToScreen=!1),this.passes=[])}render(e){const n=this.renderer,r=this.copyPass;let i=this.inputBuffer,s=this.outputBuffer,a=!1,o,l,c;e===void 0&&(this.timer.update(),e=this.timer.delta);for(const d of this.passes)d.enabled&&(d.render(n,i,s,e,a),d.needsSwap&&(a&&(r.renderToScreen=d.renderToScreen,o=n.getContext(),l=n.state.buffers.stencil,l.setFunc(o.NOTEQUAL,1,4294967295),r.render(n,i,s,e,a),l.setFunc(o.EQUAL,1,4294967295)),c=i,i=s,s=c),d instanceof _o?a=!0:d instanceof xo&&(a=!1))}setSize(e,n,r){const i=this.renderer,s=i.getSize(new me);(e===void 0||n===void 0)&&(e=s.width,n=s.height),(s.width!==e||s.height!==n)&&i.setSize(e,n,r);const a=i.getDrawingBufferSize(new me);this.inputBuffer.setSize(a.width,a.height),this.outputBuffer.setSize(a.width,a.height);for(const o of this.passes)o.setSize(a.width,a.height)}reset(){const e=this.timer.autoReset;this.dispose(),this.autoRenderToScreen=!0,this.timer.autoReset=e}dispose(){for(const e of this.passes)e.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose()}},Io=class{constructor(){this.shaderParts=new Map([[se.FRAGMENT_HEAD,null],[se.FRAGMENT_MAIN_UV,null],[se.FRAGMENT_MAIN_IMAGE,null],[se.VERTEX_HEAD,null],[se.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=Et.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=xn}},Co="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",Do="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",Uo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",Lo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Po="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",No="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",Bo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",Fo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",Oo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",ko="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",zo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",Ho="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",Go="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",jo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",Vo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",Wo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",Ko="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",Zo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",Xo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",qo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Yo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",$o="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",Qo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",Jo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",el="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",tl="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",nl="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",rl="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",il="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",sl="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",al="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",ol="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",ll=new Map([[$.ADD,Co],[$.ALPHA,Do],[$.AVERAGE,Uo],[$.COLOR,Lo],[$.COLOR_BURN,Po],[$.COLOR_DODGE,No],[$.DARKEN,Bo],[$.DIFFERENCE,Fo],[$.DIVIDE,Oo],[$.DST,null],[$.EXCLUSION,ko],[$.HARD_LIGHT,zo],[$.HARD_MIX,Ho],[$.HUE,Go],[$.INVERT,jo],[$.INVERT_RGB,Vo],[$.LIGHTEN,Wo],[$.LINEAR_BURN,Ko],[$.LINEAR_DODGE,Zo],[$.LINEAR_LIGHT,Xo],[$.LUMINOSITY,qo],[$.MULTIPLY,Yo],[$.NEGATION,$o],[$.NORMAL,Qo],[$.OVERLAY,Jo],[$.PIN_LIGHT,el],[$.REFLECT,tl],[$.SATURATION,nl],[$.SCREEN,rl],[$.SOFT_LIGHT,il],[$.SRC,sl],[$.SUBTRACT,al],[$.VIVID_LIGHT,ol]]),cl=class extends Vn{constructor(t,e=1){super(),this._blendFunction=t,this.opacity=new z(e)}getOpacity(){return this.opacity.value}setOpacity(t){this.opacity.value=t}get blendFunction(){return this._blendFunction}set blendFunction(t){this._blendFunction=t,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(t){this.blendFunction=t}getShaderCode(){return ll.get(this.blendFunction)}},Qe=class extends Vn{constructor(t,e,{attributes:n=Et.NONE,blendFunction:r=$.NORMAL,defines:i=new Map,uniforms:s=new Map,extensions:a=null,vertexShader:o=null}={}){super(),this.name=t,this.renderer=null,this.attributes=n,this.fragmentShader=e,this.vertexShader=o,this.defines=i,this.uniforms=s,this.extensions=a,this.blendMode=new cl(r),this.blendMode.addEventListener("change",l=>this.setChanged()),this._inputColorSpace=xn,this._outputColorSpace=null}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(t){this._inputColorSpace=t,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t,this.setChanged()}set mainScene(t){}set mainCamera(t){}getName(){return this.name}setRenderer(t){this.renderer=t}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(t){this.attributes=t,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(t){this.fragmentShader=t,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(t){this.vertexShader=t,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(t,e=kt){}update(t,e,n){}setSize(t,e){}initialize(t,e,n){}dispose(){for(const t of Object.keys(this)){const e=this[t];(e instanceof Re||e instanceof en||e instanceof tt||e instanceof Ge)&&this[t].dispose()}}},ul=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv)*intensity;}`,fl=class extends Qe{constructor({blendFunction:t=$.SCREEN,luminanceThreshold:e=.9,luminanceSmoothing:n=.025,mipmapBlur:r=!1,intensity:i=1,radius:s=.85,levels:a=8,kernelSize:o=nr.LARGE,resolutionScale:l=.5,width:c=Pe.AUTO_SIZE,height:d=Pe.AUTO_SIZE,resolutionX:m=c,resolutionY:f=d}={}){super("BloomEffect",ul,{blendFunction:t,uniforms:new Map([["map",new z(null)],["intensity",new z(i)]])}),this.renderTarget=new Re(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Bloom.Target",this.blurPass=new So({kernelSize:o}),this.luminancePass=new ci({colorOutput:!0}),this.luminanceMaterial.threshold=e,this.luminanceMaterial.smoothing=n,this.mipmapBlurPass=new Eo,this.mipmapBlurPass.enabled=r,this.mipmapBlurPass.radius=s,this.mipmapBlurPass.levels=a,this.uniforms.get("map").value=r?this.mipmapBlurPass.texture:this.renderTarget.texture;const p=this.resolution=new Pe(this,m,f,l);p.addEventListener("change",T=>this.setSize(p.baseWidth,p.baseHeight))}get texture(){return this.mipmapBlurPass.enabled?this.mipmapBlurPass.texture:this.renderTarget.texture}getTexture(){return this.texture}getResolution(){return this.resolution}getBlurPass(){return this.blurPass}getLuminancePass(){return this.luminancePass}get luminanceMaterial(){return this.luminancePass.fullscreenMaterial}getLuminanceMaterial(){return this.luminancePass.fullscreenMaterial}get width(){return this.resolution.width}set width(t){this.resolution.preferredWidth=t}get height(){return this.resolution.height}set height(t){this.resolution.preferredHeight=t}get dithering(){return this.blurPass.dithering}set dithering(t){this.blurPass.dithering=t}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(t){this.blurPass.kernelSize=t}get distinction(){return console.warn(this.name,"distinction was removed"),1}set distinction(t){console.warn(this.name,"distinction was removed")}get intensity(){return this.uniforms.get("intensity").value}set intensity(t){this.uniforms.get("intensity").value=t}getIntensity(){return this.intensity}setIntensity(t){this.intensity=t}getResolutionScale(){return this.resolution.scale}setResolutionScale(t){this.resolution.scale=t}update(t,e,n){const r=this.renderTarget,i=this.luminancePass;i.enabled?(i.render(t,e),this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(t,i.renderTarget):this.blurPass.render(t,i.renderTarget,r)):this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(t,e):this.blurPass.render(t,e,r)}setSize(t,e){const n=this.resolution;n.setBaseSize(t,e),this.renderTarget.setSize(n.width,n.height),this.blurPass.resolution.copy(n),this.luminancePass.setSize(t,e),this.mipmapBlurPass.setSize(t,e)}initialize(t,e,n){this.blurPass.initialize(t,e,n),this.luminancePass.initialize(t,e,n),this.mipmapBlurPass.initialize(t,e,n),n!==void 0&&(this.renderTarget.texture.type=n,t.outputEncoding===Se&&(this.renderTarget.texture.encoding=Se))}},dl="uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}",hl=class extends Qe{constructor({blendFunction:t=$.SRC,brightness:e=0,contrast:n=0}={}){super("BrightnessContrastEffect",dl,{blendFunction:t,uniforms:new Map([["brightness",new z(e)],["contrast",new z(n)]])}),this.inputColorSpace=Se}get brightness(){return this.uniforms.get("brightness").value}set brightness(t){this.uniforms.get("brightness").value=t}getBrightness(t){return this.brightness}setBrightness(t){this.brightness=t}get contrast(){return this.uniforms.get("contrast").value}set contrast(t){this.uniforms.get("contrast").value=t}getContrast(t){return this.contrast}setContrast(t){this.contrast=t}},ml="uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}",pl=class extends Qe{constructor({blendFunction:t,bits:e=16}={}){super("ColorDepthEffect",ml,{blendFunction:t,uniforms:new Map([["factor",new z(1)]])}),this.bits=0,this.bitDepth=e}get bitDepth(){return this.bits}set bitDepth(t){this.bits=t,this.uniforms.get("factor").value=Math.pow(2,t/3)}getBitDepth(){return this.bitDepth}setBitDepth(t){this.bitDepth=t}},vl=`void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){
#ifdef INVERTED
vec3 color=vec3(1.0-depth);
#else
vec3 color=vec3(depth);
#endif
outputColor=vec4(color,inputColor.a);}`,gl=class extends Qe{constructor({blendFunction:t=$.SRC,inverted:e=!1}={}){super("DepthEffect",vl,{blendFunction:t,attributes:Et.DEPTH}),this.inverted=e}get inverted(){return this.defines.has("INVERTED")}set inverted(t){this.inverted!==t&&(t?this.defines.set("INVERTED","1"):this.defines.delete("INVERTED"),this.setChanged())}isInverted(){return this.inverted}setInverted(t){this.inverted=t}},xl="uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}",wl=class extends Qe{constructor({blendFunction:t,angle:e=Math.PI*.5,scale:n=1}={}){super("DotScreenEffect",xl,{blendFunction:t,uniforms:new Map([["angle",new z(new me)],["scale",new z(n)]])}),this.angle=e}get angle(){return Math.acos(this.uniforms.get("angle").value.y)}set angle(t){this.uniforms.get("angle").value.set(Math.sin(t),Math.cos(t))}getAngle(){return this.angle}setAngle(t){this.angle=t}get scale(){return this.uniforms.get("scale").value}set scale(t){this.uniforms.get("scale").value=t}};new Q;new it;var Tl="uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}",yl=class extends Qe{constructor({blendFunction:t=$.SRC,hue:e=0,saturation:n=0}={}){super("HueSaturationEffect",Tl,{blendFunction:t,uniforms:new Map([["hue",new z(new Q)],["saturation",new z(n)]])}),this.hue=e}get saturation(){return this.uniforms.get("saturation").value}set saturation(t){this.uniforms.get("saturation").value=t}getSaturation(){return this.saturation}setSaturation(t){this.saturation=t}get hue(){const t=this.uniforms.get("hue").value;return Math.acos((t.x*3-1)/2)}set hue(t){const e=Math.sin(t),n=Math.cos(t);this.uniforms.get("hue").value.set((2*n+1)/3,(-Math.sqrt(3)*e-n+1)/3,(Math.sqrt(3)*e-n+1)/3)}getHue(){return this.hue}setHue(t){this.hue=t}};function gr(t,e,n){const r=document.createElement("canvas"),i=r.getContext("2d");if(r.width=t,r.height=e,n instanceof Image)i.drawImage(n,0,0);else{const s=i.createImageData(t,e);s.data.set(n),i.putImageData(s,0,0)}return r}var ui=class{constructor(t=0,e=0,n=null){this.width=t,this.height=e,this.data=n}toCanvas(){return typeof document>"u"?null:gr(this.width,this.height,this.data)}static from(t){const{width:e,height:n}=t;let r;if(t instanceof Image){const i=gr(e,n,t);i!==null&&(r=i.getContext("2d").getImageData(0,0,e,n).data)}else r=t.data;return new ui(e,n,r)}},Sl=`"use strict";(()=>{var O=Math.pow;var _={SCALE_UP:"lut.scaleup"};var k=[new Float32Array(3),new Float32Array(3)],n=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],Z=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function d(a,t,r,m){let i=r[0]-t[0],e=r[1]-t[1],y=r[2]-t[2],h=a[0]-t[0],A=a[1]-t[1],w=a[2]-t[2],c=e*w-y*A,l=y*h-i*w,x=i*A-e*h,u=Math.sqrt(c*c+l*l+x*x),b=u*.5,s=c/u,F=l/u,f=x/u,p=-(a[0]*s+a[1]*F+a[2]*f),M=m[0]*s+m[1]*F+m[2]*f;return Math.abs(M+p)*b/3}function V(a,t,r,m,i,e){let y=(r+m*t+i*t*t)*4;e[0]=a[y+0],e[1]=a[y+1],e[2]=a[y+2]}function j(a,t,r,m,i,e){let y=r*(t-1),h=m*(t-1),A=i*(t-1),w=Math.floor(y),c=Math.floor(h),l=Math.floor(A),x=Math.ceil(y),u=Math.ceil(h),b=Math.ceil(A),s=y-w,F=h-c,f=A-l;if(w===y&&c===h&&l===A)V(a,t,y,h,A,e);else{let p;s>=F&&F>=f?p=Z[0]:s>=f&&f>=F?p=Z[1]:f>=s&&s>=F?p=Z[2]:F>=s&&s>=f?p=Z[3]:F>=f&&f>=s?p=Z[4]:f>=F&&F>=s&&(p=Z[5]);let[M,g,X,Y]=p,P=k[0];P[0]=s,P[1]=F,P[2]=f;let o=k[1],L=x-w,S=u-c,U=b-l;o[0]=L*M[0]+w,o[1]=S*M[1]+c,o[2]=U*M[2]+l,V(a,t,o[0],o[1],o[2],n[0]),o[0]=L*g[0]+w,o[1]=S*g[1]+c,o[2]=U*g[2]+l,V(a,t,o[0],o[1],o[2],n[1]),o[0]=L*X[0]+w,o[1]=S*X[1]+c,o[2]=U*X[2]+l,V(a,t,o[0],o[1],o[2],n[2]),o[0]=L*Y[0]+w,o[1]=S*Y[1]+c,o[2]=U*Y[2]+l,V(a,t,o[0],o[1],o[2],n[3]);let T=d(g,X,Y,P)*6,q=d(M,X,Y,P)*6,C=d(M,g,Y,P)*6,E=d(M,g,X,P)*6;n[0][0]*=T,n[0][1]*=T,n[0][2]*=T,n[1][0]*=q,n[1][1]*=q,n[1][2]*=q,n[2][0]*=C,n[2][1]*=C,n[2][2]*=C,n[3][0]*=E,n[3][1]*=E,n[3][2]*=E,e[0]=n[0][0]+n[1][0]+n[2][0]+n[3][0],e[1]=n[0][1]+n[1][1]+n[2][1]+n[3][1],e[2]=n[0][2]+n[1][2]+n[2][2]+n[3][2]}}var v=class{static expand(t,r){let m=Math.cbrt(t.length/4),i=new Float32Array(3),e=new t.constructor(O(r,3)*4),y=t instanceof Uint8Array?255:1,h=O(r,2),A=1/(r-1);for(let w=0;w<r;++w)for(let c=0;c<r;++c)for(let l=0;l<r;++l){let x=l*A,u=c*A,b=w*A,s=Math.round(l+c*r+w*h)*4;j(t,m,x,u,b,i),e[s+0]=i[0],e[s+1]=i[1],e[s+2]=i[2],e[s+3]=y}return e}};self.addEventListener("message",a=>{let t=a.data,r=t.data;switch(t.operation){case _.SCALE_UP:r=v.expand(r,t.size);break}postMessage(r,[r.buffer]),close()});})();
`,xr=new Fe,pn=class extends ps{constructor(t,e){super(t,e,e,e),this.type=Ae,this.format=nt,this.encoding=xn,this.minFilter=xe,this.magFilter=xe,this.wrapS=qe,this.wrapT=qe,this.wrapR=qe,this.unpackAlignment=1,this.needsUpdate=!0,this.domainMin=new Q(0,0,0),this.domainMax=new Q(1,1,1)}get isLookupTexture3D(){return!0}scaleUp(t,e=!0){const n=this.image;let r;return t<=n.width?r=Promise.reject(new Error("The target size must be greater than the current size")):r=new Promise((i,s)=>{const a=URL.createObjectURL(new Blob([Sl],{type:"text/javascript"})),o=new Worker(a);o.addEventListener("error",c=>s(c.error)),o.addEventListener("message",c=>{const d=new pn(c.data,t);d.encoding=this.encoding,d.type=this.type,d.name=this.name,URL.revokeObjectURL(a),i(d)});const l=e?[n.data.buffer]:[];o.postMessage({operation:Xa.SCALE_UP,data:n.data,size:t},l)}),r}applyLUT(t){const e=this.image,n=t.image,r=Math.min(e.width,e.height,e.depth),i=Math.min(n.width,n.height,n.depth);if(r!==i)console.error("Size mismatch");else if(t.type!==Ae||this.type!==Ae)console.error("Both LUTs must be FloatType textures");else if(t.format!==nt||this.format!==nt)console.error("Both LUTs must be RGBA textures");else{const s=e.data,a=n.data,o=r,l=o**2,c=o-1;for(let d=0,m=o**3;d<m;++d){const f=d*4,p=s[f+0]*c,T=s[f+1]*c,g=s[f+2]*c,x=Math.round(p+T*o+g*l)*4;s[f+0]=a[x+0],s[f+1]=a[x+1],s[f+2]=a[x+2]}this.needsUpdate=!0}return this}convertToUint8(){if(this.type===Ae){const t=this.image.data,e=new Uint8Array(t.length);for(let n=0,r=t.length;n<r;++n)e[n]=t[n]*255+.5;this.image.data=e,this.type=Be,this.needsUpdate=!0}return this}convertToFloat(){if(this.type===Be){const t=this.image.data,e=new Float32Array(t.length);for(let n=0,r=t.length;n<r;++n)e[n]=t[n]/255;this.image.data=e,this.type=Ae,this.needsUpdate=!0}return this}convertToRGBA(){return console.warn("LookupTexture","convertToRGBA() is deprecated, LUTs are now RGBA by default"),this}convertLinearToSRGB(){const t=this.image.data;if(this.type===Ae){for(let e=0,n=t.length;e<n;e+=4)xr.fromArray(t,e).convertLinearToSRGB().toArray(t,e);this.encoding=Se,this.needsUpdate=!0}else console.error("Color space conversion requires FloatType data");return this}convertSRGBToLinear(){const t=this.image.data;if(this.type===Ae){for(let e=0,n=t.length;e<n;e+=4)xr.fromArray(t,e).convertSRGBToLinear().toArray(t,e);this.encoding=xn,this.needsUpdate=!0}else console.error("Color space conversion requires FloatType data");return this}toDataTexture(){const t=this.image.width,e=this.image.height*this.image.depth,n=new Nr(this.image.data,t,e);return n.name=this.name,n.type=this.type,n.format=this.format,n.encoding=this.encoding,n.minFilter=xe,n.magFilter=xe,n.wrapS=this.wrapS,n.wrapT=this.wrapT,n.generateMipmaps=!1,n.needsUpdate=!0,n}static from(t){const e=t.image,{width:n,height:r}=e,i=Math.min(n,r);let s;if(e instanceof Image){const l=ui.from(e).data;if(n>r){s=new Uint8Array(l.length);for(let c=0;c<i;++c)for(let d=0;d<i;++d)for(let m=0;m<i;++m){const f=(m+c*i+d*i*i)*4,p=(m+d*i+c*i*i)*4;s[p+0]=l[f+0],s[p+1]=l[f+1],s[p+2]=l[f+2],s[p+3]=l[f+3]}}else s=new Uint8Array(l.buffer)}else s=e.data.slice();const a=new pn(s,i);return a.encoding=t.encoding,a.type=t.type,a.name=t.name,a}static createNeutral(t){const e=new Float32Array(t**3*4),n=t**2,r=1/(t-1);for(let s=0;s<t;++s)for(let a=0;a<t;++a)for(let o=0;o<t;++o){const l=(s+a*t+o*n)*4;e[l+0]=s*r,e[l+1]=a*r,e[l+2]=o*r,e[l+3]=1}const i=new pn(e,t);return i.name="neutral",i}},_l=`void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`,El=class extends Qe{constructor({blendFunction:t=$.SCREEN,premultiply:e=!1}={}){super("NoiseEffect",_l,{blendFunction:t}),this.premultiply=e}get premultiply(){return this.defines.has("PREMULTIPLY")}set premultiply(t){this.premultiply!==t&&(t?this.defines.set("PREMULTIPLY","1"):this.defines.delete("PREMULTIPLY"),this.setChanged())}isPremultiplied(){return this.premultiply}setPremultiplied(t){this.premultiply=t}},Ml=`uniform float count;
#ifdef SCROLL
uniform float scrollSpeed;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;
#ifdef SCROLL
y+=time*scrollSpeed;
#endif
vec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}`,bl=class extends Qe{constructor({blendFunction:t=$.OVERLAY,density:e=1.25,scrollSpeed:n=0}={}){super("ScanlineEffect",Ml,{blendFunction:t,uniforms:new Map([["count",new z(0)],["scrollSpeed",new z(0)]])}),this.resolution=new me,this.d=e,this.scrollSpeed=n}get density(){return this.d}set density(t){this.d=t,this.setSize(this.resolution.width,this.resolution.height)}getDensity(){return this.density}setDensity(t){this.density=t}get scrollSpeed(){return this.uniforms.get("scrollSpeed").value}set scrollSpeed(t){this.uniforms.get("scrollSpeed").value=t,t===0?this.defines.delete("SCROLL")&&this.setChanged():this.defines.has("SCROLL")||(this.defines.set("SCROLL","1"),this.setChanged())}setSize(t,e){this.resolution.set(t,e),this.uniforms.get("count").value=Math.round(e*this.density)}},Rl="uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}",Al="uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}",Il=Math.PI*.5,Yt=new Q,wr=new Q,Cl=class extends Qe{constructor(t,e=new Q,{speed:n=2,maxRadius:r=1,waveSize:i=.2,amplitude:s=.05}={}){super("ShockWaveEffect",Rl,{vertexShader:Al,uniforms:new Map([["active",new z(!1)],["center",new z(new me(.5,.5))],["cameraDistance",new z(1)],["size",new z(1)],["radius",new z(-i)],["maxRadius",new z(r)],["waveSize",new z(i)],["amplitude",new z(s)]])}),this.position=e,this.speed=n,this.camera=t,this.screenPosition=this.uniforms.get("center").value,this.time=0,this.active=!1}set mainCamera(t){this.camera=t}get amplitude(){return this.uniforms.get("amplitude").value}set amplitude(t){this.uniforms.get("amplitude").value=t}get waveSize(){return this.uniforms.get("waveSize").value}set waveSize(t){this.uniforms.get("waveSize").value=t}get maxRadius(){return this.uniforms.get("maxRadius").value}set maxRadius(t){this.uniforms.get("maxRadius").value=t}get epicenter(){return this.position}set epicenter(t){this.position=t}getPosition(){return this.position}setPosition(t){this.position=t}getSpeed(){return this.speed}setSpeed(t){this.speed=t}explode(){this.time=0,this.active=!0,this.uniforms.get("active").value=!0}update(t,e,n){const r=this.position,i=this.camera,s=this.uniforms,a=s.get("active");if(this.active){const o=s.get("waveSize").value;i.getWorldDirection(Yt),wr.copy(i.position).sub(r),a.value=Yt.angleTo(wr)>Il,a.value&&(s.get("cameraDistance").value=i.position.distanceTo(r),Yt.copy(r).project(i),this.screenPosition.set((Yt.x+1)*.5,(Yt.y+1)*.5)),this.time+=n*this.speed;const l=this.time-o;s.get("radius").value=l,l>=(s.get("maxRadius").value+o)*2&&(this.active=!1,a.value=!1)}}},Dl="uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}",Ul=class extends Qe{constructor({blendFunction:t,intensity:e=1}={}){super("SepiaEffect",Dl,{blendFunction:t,uniforms:new Map([["weightsR",new z(new Q(.393,.769,.189))],["weightsG",new z(new Q(.349,.686,.168))],["weightsB",new z(new Q(.272,.534,.131))]])})}get intensity(){return this.blendMode.opacity.value}set intensity(t){this.blendMode.opacity.value=t}getIntensity(){return this.intensity}setIntensity(t){this.intensity=t}get weightsR(){return this.uniforms.get("weightsR").value}get weightsG(){return this.uniforms.get("weightsG").value}get weightsB(){return this.uniforms.get("weightsB").value}},Ll=`#include <tonemapping_pars_fragment>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
uniform lowp sampler2D luminanceBuffer;uniform float whitePoint;uniform float middleGrey;
#if TONE_MAPPING_MODE != 2
uniform float averageLuminance;
#endif
vec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);
#if TONE_MAPPING_MODE == 2
float lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));
#else
float lumAvg=averageLuminance;
#endif
float lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){
#if TONE_MAPPING_MODE == 1 || TONE_MAPPING_MODE == 2
outputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);
#else
outputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);
#endif
}`,Pl=class extends Qe{constructor({blendFunction:t=$.SRC,adaptive:e=!0,mode:n=e?ft.REINHARD2_ADAPTIVE:ft.REINHARD2,resolution:r=256,maxLuminance:i=16,whitePoint:s=i,middleGrey:a=.6,minLuminance:o=.01,averageLuminance:l=1,adaptationRate:c=1}={}){super("ToneMappingEffect",Ll,{blendFunction:t,uniforms:new Map([["luminanceBuffer",new z(null)],["maxLuminance",new z(i)],["whitePoint",new z(s)],["middleGrey",new z(a)],["averageLuminance",new z(l)]])}),this.renderTargetLuminance=new Re(1,1,{minFilter:Wn,depthBuffer:!1}),this.renderTargetLuminance.texture.generateMipmaps=!0,this.renderTargetLuminance.texture.name="Luminance",this.luminancePass=new ci({renderTarget:this.renderTargetLuminance}),this.adaptiveLuminancePass=new go(this.luminancePass.texture,{minLuminance:o,adaptationRate:c}),this.uniforms.get("luminanceBuffer").value=this.adaptiveLuminancePass.texture,this.resolution=r,this.mode=n}get mode(){return Number(this.defines.get("TONE_MAPPING_MODE"))}set mode(t){if(this.mode!==t){switch(this.defines.clear(),this.defines.set("TONE_MAPPING_MODE",t.toFixed(0)),t){case ft.REINHARD:this.defines.set("toneMapping(texel)","ReinhardToneMapping(texel)");break;case ft.OPTIMIZED_CINEON:this.defines.set("toneMapping(texel)","OptimizedCineonToneMapping(texel)");break;case ft.ACES_FILMIC:this.defines.set("toneMapping(texel)","ACESFilmicToneMapping(texel)");break;default:this.defines.set("toneMapping(texel)","texel");break}this.adaptiveLuminancePass.enabled=t===ft.REINHARD2_ADAPTIVE,this.setChanged()}}getMode(){return this.mode}setMode(t){this.mode=t}get whitePoint(){return this.uniforms.get("whitePoint").value}set whitePoint(t){this.uniforms.get("whitePoint").value=t}get middleGrey(){return this.uniforms.get("middleGrey").value}set middleGrey(t){this.uniforms.get("middleGrey").value=t}get averageLuminance(){return this.uniforms.get("averageLuminance").value}set averageLuminance(t){this.uniforms.get("averageLuminance").value=t}get adaptiveLuminanceMaterial(){return this.adaptiveLuminancePass.fullscreenMaterial}getAdaptiveLuminanceMaterial(){return this.adaptiveLuminanceMaterial}get resolution(){return this.luminancePass.resolution.width}set resolution(t){const e=Math.max(0,Math.ceil(Math.log2(t))),n=Math.pow(2,e);this.luminancePass.resolution.setPreferredSize(n,n),this.adaptiveLuminanceMaterial.mipLevel1x1=e}getResolution(){return this.resolution}setResolution(t){this.resolution=t}get adaptive(){return this.mode===ft.REINHARD2_ADAPTIVE}set adaptive(t){this.mode=t?ft.REINHARD2_ADAPTIVE:ft.REINHARD2}get adaptationRate(){return this.adaptiveLuminanceMaterial.adaptationRate}set adaptationRate(t){this.adaptiveLuminanceMaterial.adaptationRate=t}get distinction(){return console.warn(this.name,"distinction was removed."),1}set distinction(t){console.warn(this.name,"distinction was removed.")}update(t,e,n){this.adaptiveLuminancePass.enabled&&(this.luminancePass.render(t,e),this.adaptiveLuminancePass.render(t,null,null,n))}initialize(t,e,n){this.adaptiveLuminancePass.initialize(t,e,n)}},Nl=`uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`,Bl=class extends Qe{constructor({blendFunction:t,technique:e=hn.DEFAULT,eskil:n=!1,offset:r=.5,darkness:i=.5}={}){super("VignetteEffect",Nl,{blendFunction:t,defines:new Map([["VIGNETTE_TECHNIQUE",e.toFixed(0)]]),uniforms:new Map([["offset",new z(r)],["darkness",new z(i)]])})}get technique(){return Number(this.defines.get("VIGNETTE_TECHNIQUE"))}set technique(t){this.technique!==t&&(this.defines.set("VIGNETTE_TECHNIQUE",t.toFixed(0)),this.setChanged())}get eskil(){return this.technique===hn.ESKIL}set eskil(t){this.technique=t?hn.ESKIL:hn.DEFAULT}getTechnique(){return this.technique}setTechnique(t){this.technique=t}get offset(){return this.uniforms.get("offset").value}set offset(t){this.uniforms.get("offset").value=t}getOffset(){return this.offset}setOffset(t){this.offset=t}get darkness(){return this.uniforms.get("darkness").value}set darkness(t){this.uniforms.get("darkness").value=t}getDarkness(){return this.darkness}setDarkness(t){this.darkness=t}},Fl=class extends Tn{load(t,e=()=>{},n=()=>{},r=null){const i=this.manager,s=new Fr,a=new pt(s);return a.setPath(this.path),a.setResponseType("text"),new Promise((o,l)=>{s.onError=c=>{i.itemError(c),r!==null?(r(`Failed to load ${c}`),o()):l(`Failed to load ${c}`)},i.itemStart(t),a.load(t,c=>{try{const d=this.parse(c);i.itemEnd(t),e(d),o(d)}catch(d){console.error(d),s.onError(t)}},n)})}parse(t){const e=/TITLE +"([^"]*)"/,n=/LUT_3D_SIZE +(\d+)/,r=/DOMAIN_MIN +([\d.]+) +([\d.]+) +([\d.]+)/,i=/DOMAIN_MAX +([\d.]+) +([\d.]+) +([\d.]+)/,s=/^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm;let a=e.exec(t);const o=a!==null?a[1]:null;if(a=n.exec(t),a===null)throw new Error("Missing LUT_3D_SIZE information");const l=Number(a[1]),c=new Float32Array(l**3*4),d=new Q(0,0,0),m=new Q(1,1,1);if(a=r.exec(t),a!==null&&d.set(Number(a[1]),Number(a[2]),Number(a[3])),a=i.exec(t),a!==null&&m.set(Number(a[1]),Number(a[2]),Number(a[3])),d.x>m.x||d.y>m.y||d.z>m.z)throw d.set(0,0,0),m.set(1,1,1),new Error("Invalid input domain");let f=0;for(;(a=s.exec(t))!==null;)c[f++]=Number(a[1]),c[f++]=Number(a[2]),c[f++]=Number(a[3]),c[f++]=1;const p=new pn(c,l);return p.domainMin.copy(d),p.domainMax.copy(m),o!==null&&(p.name=o),p}};const Je=function(t,e){return e===void 0&&(e=$.NORMAL),y.forwardRef(function(r,i){let{blendFunction:s,opacity:a,...o}=r;const l=Ie(d=>d.invalidate),c=y.useMemo(()=>new t(o),[o]);return y.useLayoutEffect(()=>{c.blendMode.blendFunction=!s&&s!==0?e:s,a!==void 0&&(c.blendMode.opacity.value=a),l()},[s,c.blendMode,a]),mn.createElement("primitive",{ref:i,object:c,dispose:null})})},Ol=Je(fl,$.ADD);Je(hl);Je(pl);Je(gl);const kl=y.createContext(null),zl=mn.memo(y.forwardRef((t,e)=>{let{children:n,camera:r,scene:i,resolutionScale:s,enabled:a=!0,renderPriority:o=1,autoClear:l=!0,depthBuffer:c,disableNormalPass:d,stencilBuffer:m,multisampling:f=8,frameBufferType:p=Le}=t;const{gl:T,scene:g,camera:x,size:w}=Ie();i=i||g,r=r||x;const[I,A,R]=y.useMemo(()=>{const U=qs(),E=new Ao(T,{depthBuffer:c,stencilBuffer:m,multisampling:f>0&&U?f:0,frameBufferType:p});E.addPass(new li(i,r));let C=null,j=null;return d||(j=new Mo(i,r),j.enabled=!1,E.addPass(j),s!==void 0&&U&&(C=new wo({normalBuffer:j.texture,resolutionScale:s}),C.enabled=!1,E.addPass(C))),[E,j,C]},[r,T,c,m,f,p,i,d,s]);y.useEffect(()=>I==null?void 0:I.setSize(w.width,w.height),[I,w]),Ye((U,E)=>{a&&(T.autoClear=l,I.render(E))},a?o:0);const P=y.useRef(null);y.useLayoutEffect(()=>{let U;return P.current&&P.current.__r3f&&I&&(U=new yo(r,...P.current.__r3f.objects),U.renderToScreen=!0,I.addPass(U),A&&(A.enabled=!0),R&&(R.enabled=!0)),()=>{U&&(I==null||I.removePass(U)),A&&(A.enabled=!1),R&&(R.enabled=!1)}},[I,n,r,A,R]);const D=y.useMemo(()=>({composer:I,normalPass:A,downSamplingPass:R,resolutionScale:s,camera:r,scene:i}),[I,A,R,s,r,i]);return y.useImperativeHandle(e,()=>I,[I]),mn.createElement(kl.Provider,{value:D},mn.createElement("group",{ref:P},n))}));Je(wl);Je(yl);Je(El,$.COLOR_DODGE);Je(bl,$.OVERLAY);Je(Ul);Je(Pl);Je(Bl);Je(Cl);function Hl(){return at(Fl,__VITE_URL__+"/F-6800-STD.cube"),_.jsx(zl,{disableNormalPass:!0,children:_.jsx(Ol,{luminanceThreshold:.7,mipmapBlur:!0,luminanceSmoothing:0,intensity:1.4,radius:.85})})}const An=new WeakMap;class an extends Tn{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,n,r,i){const s=new pt(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,a=>{this.decodeDracoFile(a,n).catch(i)},r,i)}decodeDracoFile(e,n,r,i){const s={attributeIDs:r||this.defaultAttributeIDs,attributeTypes:i||this.defaultAttributeTypes,useUniqueIDs:!!r};return this.decodeGeometry(e,s).then(n)}decodeGeometry(e,n){const r=JSON.stringify(n);if(An.has(e)){const l=An.get(e);if(l.key===r)return l.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let i;const s=this.workerNextTaskID++,a=e.byteLength,o=this._getWorker(s,a).then(l=>(i=l,new Promise((c,d)=>{i._callbacks[s]={resolve:c,reject:d},i.postMessage({type:"decode",id:s,taskConfig:n,buffer:e},[e])}))).then(l=>this._createGeometry(l.geometry));return o.catch(()=>!0).then(()=>{i&&s&&this._releaseTask(i,s)}),An.set(e,{key:r,promise:o}),o}_createGeometry(e){const n=new Ot;e.index&&n.setIndex(new be(e.index.array,1));for(let r=0;r<e.attributes.length;r++){const i=e.attributes[r],s=i.name,a=i.array,o=i.itemSize;n.setAttribute(s,new be(a,o))}return n}_loadLibrary(e,n){const r=new pt(this.manager);return r.setPath(this.decoderPath),r.setResponseType(n),r.setWithCredentials(this.withCredentials),new Promise((i,s)=>{r.load(e,i,void 0,s)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",n=[];return e?n.push(this._loadLibrary("draco_decoder.js","text")):(n.push(this._loadLibrary("draco_wasm_wrapper.js","text")),n.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(n).then(r=>{const i=r[0];e||(this.decoderConfig.wasmBinary=r[1]);const s=Gl.toString(),a=["/* draco decoder */",i,"","/* worker */",s.substring(s.indexOf("{")+1,s.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([a]))}),this.decoderPending}_getWorker(e,n){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const i=new Worker(this.workerSourceURL);i._callbacks={},i._taskCosts={},i._taskLoad=0,i.postMessage({type:"init",decoderConfig:this.decoderConfig}),i.onmessage=function(s){const a=s.data;switch(a.type){case"decode":i._callbacks[a.id].resolve(a);break;case"error":i._callbacks[a.id].reject(a);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+a.type+'"')}},this.workerPool.push(i)}else this.workerPool.sort(function(i,s){return i._taskLoad>s._taskLoad?-1:1});const r=this.workerPool[this.workerPool.length-1];return r._taskCosts[e]=n,r._taskLoad+=n,r})}_releaseTask(e,n){e._taskLoad-=e._taskCosts[n],delete e._callbacks[n],delete e._taskCosts[n]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function Gl(){let t,e;onmessage=function(a){const o=a.data;switch(o.type){case"init":t=o.decoderConfig,e=new Promise(function(d){t.onModuleLoaded=function(m){d({draco:m})},DracoDecoderModule(t)});break;case"decode":const l=o.buffer,c=o.taskConfig;e.then(d=>{const m=d.draco,f=new m.Decoder,p=new m.DecoderBuffer;p.Init(new Int8Array(l),l.byteLength);try{const T=n(m,f,p,c),g=T.attributes.map(x=>x.array.buffer);T.index&&g.push(T.index.array.buffer),self.postMessage({type:"decode",id:o.id,geometry:T},g)}catch(T){console.error(T),self.postMessage({type:"error",id:o.id,error:T.message})}finally{m.destroy(p),m.destroy(f)}});break}};function n(a,o,l,c){const d=c.attributeIDs,m=c.attributeTypes;let f,p;const T=o.GetEncodedGeometryType(l);if(T===a.TRIANGULAR_MESH)f=new a.Mesh,p=o.DecodeBufferToMesh(l,f);else if(T===a.POINT_CLOUD)f=new a.PointCloud,p=o.DecodeBufferToPointCloud(l,f);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!p.ok()||f.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+p.error_msg());const g={index:null,attributes:[]};for(const x in d){const w=self[m[x]];let I,A;if(c.useUniqueIDs)A=d[x],I=o.GetAttributeByUniqueId(f,A);else{if(A=o.GetAttributeId(f,a[d[x]]),A===-1)continue;I=o.GetAttribute(f,A)}g.attributes.push(i(a,o,f,x,w,I))}return T===a.TRIANGULAR_MESH&&(g.index=r(a,o,f)),a.destroy(f),g}function r(a,o,l){const d=l.num_faces()*3,m=d*4,f=a._malloc(m);o.GetTrianglesUInt32Array(l,m,f);const p=new Uint32Array(a.HEAPF32.buffer,f,d).slice();return a._free(f),{array:p,itemSize:1}}function i(a,o,l,c,d,m){const f=m.num_components(),T=l.num_points()*f,g=T*d.BYTES_PER_ELEMENT,x=s(a,d),w=a._malloc(g);o.GetAttributeDataArrayForAllPoints(l,m,x,g,w);const I=new d(a.HEAPF32.buffer,w,T).slice();return a._free(w),{name:c,array:I,itemSize:f}}function s(a,o){switch(o){case Float32Array:return a.DT_FLOAT32;case Int8Array:return a.DT_INT8;case Int16Array:return a.DT_INT16;case Int32Array:return a.DT_INT32;case Uint8Array:return a.DT_UINT8;case Uint16Array:return a.DT_UINT16;case Uint32Array:return a.DT_UINT32}}}class on extends Tn{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(n){return new Zl(n)}),this.register(function(n){return new ec(n)}),this.register(function(n){return new tc(n)}),this.register(function(n){return new ql(n)}),this.register(function(n){return new Yl(n)}),this.register(function(n){return new $l(n)}),this.register(function(n){return new Ql(n)}),this.register(function(n){return new Kl(n)}),this.register(function(n){return new Jl(n)}),this.register(function(n){return new Xl(n)}),this.register(function(n){return new Vl(n)}),this.register(function(n){return new nc(n)}),this.register(function(n){return new rc(n)})}load(e,n,r,i){const s=this;let a;this.resourcePath!==""?a=this.resourcePath:this.path!==""?a=this.path:a=At.extractUrlBase(e),this.manager.itemStart(e);const o=function(c){i?i(c):console.error(c),s.manager.itemError(e),s.manager.itemEnd(e)},l=new pt(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{s.parse(c,a,function(d){n(d),s.manager.itemEnd(e)},o)}catch(d){o(d)}},r,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,n,r,i){let s;const a={},o={};if(typeof e=="string")s=JSON.parse(e);else if(e instanceof ArrayBuffer)if(At.decodeText(new Uint8Array(e,0,4))===fi){try{a[ie.KHR_BINARY_GLTF]=new ic(e)}catch(d){i&&i(d);return}s=JSON.parse(a[ie.KHR_BINARY_GLTF].content)}else s=JSON.parse(At.decodeText(new Uint8Array(e)));else s=e;if(s.asset===void 0||s.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new gc(s,{path:n||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const d=this.pluginCallbacks[c](l);o[d.name]=d,a[d.name]=!0}if(s.extensionsUsed)for(let c=0;c<s.extensionsUsed.length;++c){const d=s.extensionsUsed[c],m=s.extensionsRequired||[];switch(d){case ie.KHR_MATERIALS_UNLIT:a[d]=new Wl;break;case ie.KHR_DRACO_MESH_COMPRESSION:a[d]=new sc(s,this.dracoLoader);break;case ie.KHR_TEXTURE_TRANSFORM:a[d]=new ac;break;case ie.KHR_MESH_QUANTIZATION:a[d]=new oc;break;default:m.indexOf(d)>=0&&o[d]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+d+'".')}}l.setExtensions(a),l.setPlugins(o),l.parse(r,i)}parseAsync(e,n){const r=this;return new Promise(function(i,s){r.parse(e,n,i,s)})}}function jl(){let t={};return{get:function(e){return t[e]},add:function(e,n){t[e]=n},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const ie={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Vl{constructor(e){this.parser=e,this.name=ie.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,n=this.parser.json.nodes||[];for(let r=0,i=n.length;r<i;r++){const s=n[r];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const n=this.parser,r="light:"+e;let i=n.cache.get(r);if(i)return i;const s=n.json,l=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let c;const d=new Fe(16777215);l.color!==void 0&&d.fromArray(l.color);const m=l.range!==void 0?l.range:0;switch(l.type){case"directional":c=new xs(d),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new gs(d),c.distance=m;break;case"spot":c=new vs(d),c.distance=m,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,St(c,l),l.intensity!==void 0&&(c.intensity=l.intensity),c.name=n.createUniqueName(l.name||"light_"+e),i=Promise.resolve(c),n.cache.add(r,i),i}getDependency(e,n){if(e==="light")return this._loadLight(n)}createNodeAttachment(e){const n=this,r=this.parser,s=r.json.nodes[e],o=(s.extensions&&s.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(l){return r._getNodeRef(n.cache,o,l)})}}class Wl{constructor(){this.name=ie.KHR_MATERIALS_UNLIT}getMaterialType(){return mt}extendParams(e,n,r){const i=[];e.color=new Fe(1,1,1),e.opacity=1;const s=n.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const a=s.baseColorFactor;e.color.fromArray(a),e.opacity=a[3]}s.baseColorTexture!==void 0&&i.push(r.assignTexture(e,"map",s.baseColorTexture,Se))}return Promise.all(i)}}class Kl{constructor(e){this.parser=e,this.name=ie.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,n){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name].emissiveStrength;return s!==void 0&&(n.emissiveIntensity=s),Promise.resolve()}}class Zl{constructor(e){this.parser=e,this.name=ie.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Dt}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];if(a.clearcoatFactor!==void 0&&(n.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&s.push(r.assignTexture(n,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(n.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&s.push(r.assignTexture(n,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(s.push(r.assignTexture(n,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const o=a.clearcoatNormalTexture.scale;n.clearcoatNormalScale=new me(o,o)}return Promise.all(s)}}class Xl{constructor(e){this.parser=e,this.name=ie.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Dt}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return a.iridescenceFactor!==void 0&&(n.iridescence=a.iridescenceFactor),a.iridescenceTexture!==void 0&&s.push(r.assignTexture(n,"iridescenceMap",a.iridescenceTexture)),a.iridescenceIor!==void 0&&(n.iridescenceIOR=a.iridescenceIor),n.iridescenceThicknessRange===void 0&&(n.iridescenceThicknessRange=[100,400]),a.iridescenceThicknessMinimum!==void 0&&(n.iridescenceThicknessRange[0]=a.iridescenceThicknessMinimum),a.iridescenceThicknessMaximum!==void 0&&(n.iridescenceThicknessRange[1]=a.iridescenceThicknessMaximum),a.iridescenceThicknessTexture!==void 0&&s.push(r.assignTexture(n,"iridescenceThicknessMap",a.iridescenceThicknessTexture)),Promise.all(s)}}class ql{constructor(e){this.parser=e,this.name=ie.KHR_MATERIALS_SHEEN}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Dt}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[];n.sheenColor=new Fe(0,0,0),n.sheenRoughness=0,n.sheen=1;const a=i.extensions[this.name];return a.sheenColorFactor!==void 0&&n.sheenColor.fromArray(a.sheenColorFactor),a.sheenRoughnessFactor!==void 0&&(n.sheenRoughness=a.sheenRoughnessFactor),a.sheenColorTexture!==void 0&&s.push(r.assignTexture(n,"sheenColorMap",a.sheenColorTexture,Se)),a.sheenRoughnessTexture!==void 0&&s.push(r.assignTexture(n,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(s)}}class Yl{constructor(e){this.parser=e,this.name=ie.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Dt}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return a.transmissionFactor!==void 0&&(n.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&s.push(r.assignTexture(n,"transmissionMap",a.transmissionTexture)),Promise.all(s)}}class $l{constructor(e){this.parser=e,this.name=ie.KHR_MATERIALS_VOLUME}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Dt}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];n.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0,a.thicknessTexture!==void 0&&s.push(r.assignTexture(n,"thicknessMap",a.thicknessTexture)),n.attenuationDistance=a.attenuationDistance||1/0;const o=a.attenuationColor||[1,1,1];return n.attenuationColor=new Fe(o[0],o[1],o[2]),Promise.all(s)}}class Ql{constructor(e){this.parser=e,this.name=ie.KHR_MATERIALS_IOR}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Dt}extendMaterialParams(e,n){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name];return n.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}}class Jl{constructor(e){this.parser=e,this.name=ie.KHR_MATERIALS_SPECULAR}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Dt}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];n.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1,a.specularTexture!==void 0&&s.push(r.assignTexture(n,"specularIntensityMap",a.specularTexture));const o=a.specularColorFactor||[1,1,1];return n.specularColor=new Fe(o[0],o[1],o[2]),a.specularColorTexture!==void 0&&s.push(r.assignTexture(n,"specularColorMap",a.specularColorTexture,Se)),Promise.all(s)}}class ec{constructor(e){this.parser=e,this.name=ie.KHR_TEXTURE_BASISU}loadTexture(e){const n=this.parser,r=n.json,i=r.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const s=i.extensions[this.name],a=n.options.ktx2Loader;if(!a){if(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return n.loadTextureImage(e,s.source,a)}}class tc{constructor(e){this.parser=e,this.name=ie.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const n=this.name,r=this.parser,i=r.json,s=i.textures[e];if(!s.extensions||!s.extensions[n])return null;const a=s.extensions[n],o=i.images[a.source];let l=r.textureLoader;if(o.uri){const c=r.options.manager.getHandler(o.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return r.loadTextureImage(e,a.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return r.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const n=new Image;n.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",n.onload=n.onerror=function(){e(n.height===1)}})),this.isSupported}}class nc{constructor(e){this.name=ie.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const n=this.parser.json,r=n.bufferViews[e];if(r.extensions&&r.extensions[this.name]){const i=r.extensions[this.name],s=this.parser.getDependency("buffer",i.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(o){const l=i.byteOffset||0,c=i.byteLength||0,d=i.count,m=i.byteStride,f=new Uint8Array(o,l,c);return a.decodeGltfBufferAsync?a.decodeGltfBufferAsync(d,m,f,i.mode,i.filter).then(function(p){return p.buffer}):a.ready.then(function(){const p=new ArrayBuffer(d*m);return a.decodeGltfBuffer(new Uint8Array(p),d,m,f,i.mode,i.filter),p})})}else return null}}class rc{constructor(e){this.name=ie.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const n=this.parser.json,r=n.nodes[e];if(!r.extensions||!r.extensions[this.name]||r.mesh===void 0)return null;const i=n.meshes[r.mesh];for(const c of i.primitives)if(c.mode!==Ze.TRIANGLES&&c.mode!==Ze.TRIANGLE_STRIP&&c.mode!==Ze.TRIANGLE_FAN&&c.mode!==void 0)return null;const a=r.extensions[this.name].attributes,o=[],l={};for(const c in a)o.push(this.parser.getDependency("accessor",a[c]).then(d=>(l[c]=d,l[c])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(c=>{const d=c.pop(),m=d.isGroup?d.children:[d],f=c[0].count,p=[];for(const T of m){const g=new it,x=new Q,w=new kn,I=new Q(1,1,1),A=new ws(T.geometry,T.material,f);for(let R=0;R<f;R++)l.TRANSLATION&&x.fromBufferAttribute(l.TRANSLATION,R),l.ROTATION&&w.fromBufferAttribute(l.ROTATION,R),l.SCALE&&I.fromBufferAttribute(l.SCALE,R),A.setMatrixAt(R,g.compose(x,w,I));for(const R in l)R!=="TRANSLATION"&&R!=="ROTATION"&&R!=="SCALE"&&T.geometry.setAttribute(R,l[R]);kr.prototype.copy.call(A,T),A.frustumCulled=!1,this.parser.assignFinalMaterial(A),p.push(A)}return d.isGroup?(d.clear(),d.add(...p),d):p[0]}))}}const fi="glTF",$t=12,Tr={JSON:1313821514,BIN:5130562};class ic{constructor(e){this.name=ie.KHR_BINARY_GLTF,this.content=null,this.body=null;const n=new DataView(e,0,$t);if(this.header={magic:At.decodeText(new Uint8Array(e.slice(0,4))),version:n.getUint32(4,!0),length:n.getUint32(8,!0)},this.header.magic!==fi)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const r=this.header.length-$t,i=new DataView(e,$t);let s=0;for(;s<r;){const a=i.getUint32(s,!0);s+=4;const o=i.getUint32(s,!0);if(s+=4,o===Tr.JSON){const l=new Uint8Array(e,$t+s,a);this.content=At.decodeText(l)}else if(o===Tr.BIN){const l=$t+s;this.body=e.slice(l,l+a)}s+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class sc{constructor(e,n){if(!n)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=ie.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=n,this.dracoLoader.preload()}decodePrimitive(e,n){const r=this.json,i=this.dracoLoader,s=e.extensions[this.name].bufferView,a=e.extensions[this.name].attributes,o={},l={},c={};for(const d in a){const m=Fn[d]||d.toLowerCase();o[m]=a[d]}for(const d in e.attributes){const m=Fn[d]||d.toLowerCase();if(a[d]!==void 0){const f=r.accessors[e.attributes[d]],p=Nt[f.componentType];c[m]=p.name,l[m]=f.normalized===!0}}return n.getDependency("bufferView",s).then(function(d){return new Promise(function(m){i.decodeDracoFile(d,function(f){for(const p in f.attributes){const T=f.attributes[p],g=l[p];g!==void 0&&(T.normalized=g)}m(f)},o,c)})})}}class ac{constructor(){this.name=ie.KHR_TEXTURE_TRANSFORM}extendTexture(e,n){return n.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),n.offset===void 0&&n.rotation===void 0&&n.scale===void 0||(e=e.clone(),n.offset!==void 0&&e.offset.fromArray(n.offset),n.rotation!==void 0&&(e.rotation=n.rotation),n.scale!==void 0&&e.repeat.fromArray(n.scale),e.needsUpdate=!0),e}}class oc{constructor(){this.name=ie.KHR_MESH_QUANTIZATION}}class di extends zs{constructor(e,n,r,i){super(e,n,r,i)}copySampleValue_(e){const n=this.resultBuffer,r=this.sampleValues,i=this.valueSize,s=e*i*3+i;for(let a=0;a!==i;a++)n[a]=r[s+a];return n}interpolate_(e,n,r,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=o*2,c=o*3,d=i-n,m=(r-n)/d,f=m*m,p=f*m,T=e*c,g=T-c,x=-2*p+3*f,w=p-f,I=1-x,A=w-f+m;for(let R=0;R!==o;R++){const P=a[g+R+o],D=a[g+R+l]*d,U=a[T+R+o],E=a[T+R]*d;s[R]=I*P+A*D+x*U+w*E}return s}}const lc=new kn;class cc extends di{interpolate_(e,n,r,i){const s=super.interpolate_(e,n,r,i);return lc.fromArray(s).normalize().toArray(s),s}}const Ze={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Nt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},yr={9728:Ct,9729:xe,9984:Ds,9985:Us,9986:Ls,9987:Wn},Sr={33071:qe,33648:Ps,10497:Pn},In={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Fn={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},yt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},uc={CUBICSPLINE:void 0,LINEAR:Hr,STEP:Ns},Cn={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function fc(t){return t.DefaultMaterial===void 0&&(t.DefaultMaterial=new zn({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Or})),t.DefaultMaterial}function Qt(t,e,n){for(const r in n.extensions)t[r]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[r]=n.extensions[r])}function St(t,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(t.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function dc(t,e,n){let r=!1,i=!1,s=!1;for(let c=0,d=e.length;c<d;c++){const m=e[c];if(m.POSITION!==void 0&&(r=!0),m.NORMAL!==void 0&&(i=!0),m.COLOR_0!==void 0&&(s=!0),r&&i&&s)break}if(!r&&!i&&!s)return Promise.resolve(t);const a=[],o=[],l=[];for(let c=0,d=e.length;c<d;c++){const m=e[c];if(r){const f=m.POSITION!==void 0?n.getDependency("accessor",m.POSITION):t.attributes.position;a.push(f)}if(i){const f=m.NORMAL!==void 0?n.getDependency("accessor",m.NORMAL):t.attributes.normal;o.push(f)}if(s){const f=m.COLOR_0!==void 0?n.getDependency("accessor",m.COLOR_0):t.attributes.color;l.push(f)}}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l)]).then(function(c){const d=c[0],m=c[1],f=c[2];return r&&(t.morphAttributes.position=d),i&&(t.morphAttributes.normal=m),s&&(t.morphAttributes.color=f),t.morphTargetsRelative=!0,t})}function hc(t,e){if(t.updateMorphTargets(),e.weights!==void 0)for(let n=0,r=e.weights.length;n<r;n++)t.morphTargetInfluences[n]=e.weights[n];if(e.extras&&Array.isArray(e.extras.targetNames)){const n=e.extras.targetNames;if(t.morphTargetInfluences.length===n.length){t.morphTargetDictionary={};for(let r=0,i=n.length;r<i;r++)t.morphTargetDictionary[n[r]]=r}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function mc(t){const e=t.extensions&&t.extensions[ie.KHR_DRACO_MESH_COMPRESSION];let n;return e?n="draco:"+e.bufferView+":"+e.indices+":"+_r(e.attributes):n=t.indices+":"+_r(t.attributes)+":"+t.mode,n}function _r(t){let e="";const n=Object.keys(t).sort();for(let r=0,i=n.length;r<i;r++)e+=n[r]+":"+t[n[r]]+";";return e}function On(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function pc(t){return t.search(/\.jpe?g($|\?)/i)>0||t.search(/^data\:image\/jpeg/)===0?"image/jpeg":t.search(/\.webp($|\?)/i)>0||t.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const vc=new it;class gc{constructor(e={},n={}){this.json=e,this.extensions={},this.plugins={},this.options=n,this.cache=new jl,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let r=!1,i=!1,s=-1;typeof navigator<"u"&&(r=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,i=navigator.userAgent.indexOf("Firefox")>-1,s=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||r||i&&s<98?this.textureLoader=new zr(this.options.manager):this.textureLoader=new Ts(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new pt(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,n){const r=this,i=this.json,s=this.extensions;this.cache.removeAll(),this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([r.getDependencies("scene"),r.getDependencies("animation"),r.getDependencies("camera")])}).then(function(a){const o={scene:a[0][i.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:i.asset,parser:r,userData:{}};Qt(s,o,i),St(o,i),Promise.all(r._invokeAll(function(l){return l.afterRoot&&l.afterRoot(o)})).then(function(){e(o)})}).catch(n)}_markDefs(){const e=this.json.nodes||[],n=this.json.skins||[],r=this.json.meshes||[];for(let i=0,s=n.length;i<s;i++){const a=n[i].joints;for(let o=0,l=a.length;o<l;o++)e[a[o]].isBone=!0}for(let i=0,s=e.length;i<s;i++){const a=e[i];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(r[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(e,n){n!==void 0&&(e.refs[n]===void 0&&(e.refs[n]=e.uses[n]=0),e.refs[n]++)}_getNodeRef(e,n,r){if(e.refs[n]<=1)return r;const i=r.clone(),s=(a,o)=>{const l=this.associations.get(a);l!=null&&this.associations.set(o,l);for(const[c,d]of a.children.entries())s(d,o.children[c])};return s(r,i),i.name+="_instance_"+e.uses[n]++,i}_invokeOne(e){const n=Object.values(this.plugins);n.push(this);for(let r=0;r<n.length;r++){const i=e(n[r]);if(i)return i}return null}_invokeAll(e){const n=Object.values(this.plugins);n.unshift(this);const r=[];for(let i=0;i<n.length;i++){const s=e(n[i]);s&&r.push(s)}return r}getDependency(e,n){const r=e+":"+n;let i=this.cache.get(r);if(!i){switch(e){case"scene":i=this.loadScene(n);break;case"node":i=this._invokeOne(function(s){return s.loadNode&&s.loadNode(n)});break;case"mesh":i=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(n)});break;case"accessor":i=this.loadAccessor(n);break;case"bufferView":i=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(n)});break;case"buffer":i=this.loadBuffer(n);break;case"material":i=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(n)});break;case"texture":i=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(n)});break;case"skin":i=this.loadSkin(n);break;case"animation":i=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(n)});break;case"camera":i=this.loadCamera(n);break;default:if(i=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(e,n)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(r,i)}return i}getDependencies(e){let n=this.cache.get(e);if(!n){const r=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];n=Promise.all(i.map(function(s,a){return r.getDependency(e,a)})),this.cache.add(e,n)}return n}loadBuffer(e){const n=this.json.buffers[e],r=this.fileLoader;if(n.type&&n.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+n.type+" buffer type is not supported.");if(n.uri===void 0&&e===0)return Promise.resolve(this.extensions[ie.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(s,a){r.load(At.resolveURL(n.uri,i.path),s,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+n.uri+'".'))})})}loadBufferView(e){const n=this.json.bufferViews[e];return this.getDependency("buffer",n.buffer).then(function(r){const i=n.byteLength||0,s=n.byteOffset||0;return r.slice(s,s+i)})}loadAccessor(e){const n=this,r=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const a=In[i.type],o=Nt[i.componentType],l=i.normalized===!0,c=new o(i.count*a);return Promise.resolve(new be(c,a,l))}const s=[];return i.bufferView!==void 0?s.push(this.getDependency("bufferView",i.bufferView)):s.push(null),i.sparse!==void 0&&(s.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(s).then(function(a){const o=a[0],l=In[i.type],c=Nt[i.componentType],d=c.BYTES_PER_ELEMENT,m=d*l,f=i.byteOffset||0,p=i.bufferView!==void 0?r.bufferViews[i.bufferView].byteStride:void 0,T=i.normalized===!0;let g,x;if(p&&p!==m){const w=Math.floor(f/p),I="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+w+":"+i.count;let A=n.cache.get(I);A||(g=new c(o,w*p,i.count*p/d),A=new ys(g,p/d),n.cache.add(I,A)),x=new Bs(A,l,f%p/d,T)}else o===null?g=new c(i.count*l):g=new c(o,f,i.count*l),x=new be(g,l,T);if(i.sparse!==void 0){const w=In.SCALAR,I=Nt[i.sparse.indices.componentType],A=i.sparse.indices.byteOffset||0,R=i.sparse.values.byteOffset||0,P=new I(a[1],A,i.sparse.count*w),D=new c(a[2],R,i.sparse.count*l);o!==null&&(x=new be(x.array.slice(),x.itemSize,x.normalized));for(let U=0,E=P.length;U<E;U++){const C=P[U];if(x.setX(C,D[U*l]),l>=2&&x.setY(C,D[U*l+1]),l>=3&&x.setZ(C,D[U*l+2]),l>=4&&x.setW(C,D[U*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return x})}loadTexture(e){const n=this.json,r=this.options,s=n.textures[e].source,a=n.images[s];let o=this.textureLoader;if(a.uri){const l=r.manager.getHandler(a.uri);l!==null&&(o=l)}return this.loadTextureImage(e,s,o)}loadTextureImage(e,n,r){const i=this,s=this.json,a=s.textures[e],o=s.images[n],l=(o.uri||o.bufferView)+":"+a.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(n,r).then(function(d){d.flipY=!1,d.name=a.name||o.name||"";const f=(s.samplers||{})[a.sampler]||{};return d.magFilter=yr[f.magFilter]||xe,d.minFilter=yr[f.minFilter]||Wn,d.wrapS=Sr[f.wrapS]||Pn,d.wrapT=Sr[f.wrapT]||Pn,i.associations.set(d,{textures:e}),d}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,n){const r=this,i=this.json,s=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(m=>m.clone());const a=i.images[e],o=self.URL||self.webkitURL;let l=a.uri||"",c=!1;if(a.bufferView!==void 0)l=r.getDependency("bufferView",a.bufferView).then(function(m){c=!0;const f=new Blob([m],{type:a.mimeType});return l=o.createObjectURL(f),l});else if(a.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const d=Promise.resolve(l).then(function(m){return new Promise(function(f,p){let T=f;n.isImageBitmapLoader===!0&&(T=function(g){const x=new tt(g);x.needsUpdate=!0,f(x)}),n.load(At.resolveURL(m,s.path),T,void 0,p)})}).then(function(m){return c===!0&&o.revokeObjectURL(l),m.userData.mimeType=a.mimeType||pc(a.uri),m}).catch(function(m){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),m});return this.sourceCache[e]=d,d}assignTexture(e,n,r,i){const s=this;return this.getDependency("texture",r.index).then(function(a){if(!a)return null;if(r.texCoord!==void 0&&r.texCoord!=0&&!(n==="aoMap"&&r.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+r.texCoord+" for texture "+n+" not yet supported."),s.extensions[ie.KHR_TEXTURE_TRANSFORM]){const o=r.extensions!==void 0?r.extensions[ie.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const l=s.associations.get(a);a=s.extensions[ie.KHR_TEXTURE_TRANSFORM].extendTexture(a,o),s.associations.set(a,l)}}return i!==void 0&&(a.encoding=i),e[n]=a,a})}assignFinalMaterial(e){const n=e.geometry;let r=e.material;const i=n.attributes.tangent===void 0,s=n.attributes.color!==void 0,a=n.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+r.uuid;let l=this.cache.get(o);l||(l=new Kn,en.prototype.copy.call(l,r),l.color.copy(r.color),l.map=r.map,l.sizeAttenuation=!1,this.cache.add(o,l)),r=l}else if(e.isLine){const o="LineBasicMaterial:"+r.uuid;let l=this.cache.get(o);l||(l=new Ss,en.prototype.copy.call(l,r),l.color.copy(r.color),this.cache.add(o,l)),r=l}if(i||s||a){let o="ClonedMaterial:"+r.uuid+":";i&&(o+="derivative-tangents:"),s&&(o+="vertex-colors:"),a&&(o+="flat-shading:");let l=this.cache.get(o);l||(l=r.clone(),s&&(l.vertexColors=!0),a&&(l.flatShading=!0),i&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(o,l),this.associations.set(l,this.associations.get(r))),r=l}r.aoMap&&n.attributes.uv2===void 0&&n.attributes.uv!==void 0&&n.setAttribute("uv2",n.attributes.uv),e.material=r}getMaterialType(){return zn}loadMaterial(e){const n=this,r=this.json,i=this.extensions,s=r.materials[e];let a;const o={},l=s.extensions||{},c=[];if(l[ie.KHR_MATERIALS_UNLIT]){const m=i[ie.KHR_MATERIALS_UNLIT];a=m.getMaterialType(),c.push(m.extendParams(o,s,n))}else{const m=s.pbrMetallicRoughness||{};if(o.color=new Fe(1,1,1),o.opacity=1,Array.isArray(m.baseColorFactor)){const f=m.baseColorFactor;o.color.fromArray(f),o.opacity=f[3]}m.baseColorTexture!==void 0&&c.push(n.assignTexture(o,"map",m.baseColorTexture,Se)),o.metalness=m.metallicFactor!==void 0?m.metallicFactor:1,o.roughness=m.roughnessFactor!==void 0?m.roughnessFactor:1,m.metallicRoughnessTexture!==void 0&&(c.push(n.assignTexture(o,"metalnessMap",m.metallicRoughnessTexture)),c.push(n.assignTexture(o,"roughnessMap",m.metallicRoughnessTexture))),a=this._invokeOne(function(f){return f.getMaterialType&&f.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(f){return f.extendMaterialParams&&f.extendMaterialParams(e,o)})))}s.doubleSided===!0&&(o.side=ht);const d=s.alphaMode||Cn.OPAQUE;if(d===Cn.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,d===Cn.MASK&&(o.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&a!==mt&&(c.push(n.assignTexture(o,"normalMap",s.normalTexture)),o.normalScale=new me(1,1),s.normalTexture.scale!==void 0)){const m=s.normalTexture.scale;o.normalScale.set(m,m)}return s.occlusionTexture!==void 0&&a!==mt&&(c.push(n.assignTexture(o,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&a!==mt&&(o.emissive=new Fe().fromArray(s.emissiveFactor)),s.emissiveTexture!==void 0&&a!==mt&&c.push(n.assignTexture(o,"emissiveMap",s.emissiveTexture,Se)),Promise.all(c).then(function(){const m=new a(o);return s.name&&(m.name=s.name),St(m,s),n.associations.set(m,{materials:e}),s.extensions&&Qt(i,m,s),m})}createUniqueName(e){const n=_s.sanitizeNodeName(e||"");let r=n;for(let i=1;this.nodeNamesUsed[r];++i)r=n+"_"+i;return this.nodeNamesUsed[r]=!0,r}loadGeometries(e){const n=this,r=this.extensions,i=this.primitiveCache;function s(o){return r[ie.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,n).then(function(l){return Er(l,o,n)})}const a=[];for(let o=0,l=e.length;o<l;o++){const c=e[o],d=mc(c),m=i[d];if(m)a.push(m.promise);else{let f;c.extensions&&c.extensions[ie.KHR_DRACO_MESH_COMPRESSION]?f=s(c):f=Er(new Ot,c,n),i[d]={primitive:c,promise:f},a.push(f)}}return Promise.all(a)}loadMesh(e){const n=this,r=this.json,i=this.extensions,s=r.meshes[e],a=s.primitives,o=[];for(let l=0,c=a.length;l<c;l++){const d=a[l].material===void 0?fc(this.cache):this.getDependency("material",a[l].material);o.push(d)}return o.push(n.loadGeometries(a)),Promise.all(o).then(function(l){const c=l.slice(0,l.length-1),d=l[l.length-1],m=[];for(let p=0,T=d.length;p<T;p++){const g=d[p],x=a[p];let w;const I=c[p];if(x.mode===Ze.TRIANGLES||x.mode===Ze.TRIANGLE_STRIP||x.mode===Ze.TRIANGLE_FAN||x.mode===void 0)w=s.isSkinnedMesh===!0?new Es(g,I):new st(g,I),w.isSkinnedMesh===!0&&!w.geometry.attributes.skinWeight.normalized&&w.normalizeSkinWeights(),x.mode===Ze.TRIANGLE_STRIP?w.geometry=Mr(w.geometry,Fs):x.mode===Ze.TRIANGLE_FAN&&(w.geometry=Mr(w.geometry,Gr));else if(x.mode===Ze.LINES)w=new Ms(g,I);else if(x.mode===Ze.LINE_STRIP)w=new bs(g,I);else if(x.mode===Ze.LINE_LOOP)w=new Rs(g,I);else if(x.mode===Ze.POINTS)w=new Zn(g,I);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+x.mode);Object.keys(w.geometry.morphAttributes).length>0&&hc(w,s),w.name=n.createUniqueName(s.name||"mesh_"+e),St(w,s),x.extensions&&Qt(i,w,x),n.assignFinalMaterial(w),m.push(w)}for(let p=0,T=m.length;p<T;p++)n.associations.set(m[p],{meshes:e,primitives:p});if(m.length===1)return m[0];const f=new _n;n.associations.set(f,{meshes:e});for(let p=0,T=m.length;p<T;p++)f.add(m[p]);return f})}loadCamera(e){let n;const r=this.json.cameras[e],i=r[r.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return r.type==="perspective"?n=new Gn(As.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):r.type==="orthographic"&&(n=new Pr(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),r.name&&(n.name=this.createUniqueName(r.name)),St(n,r),Promise.resolve(n)}loadSkin(e){const n=this.json.skins[e],r=[];for(let i=0,s=n.joints.length;i<s;i++)r.push(this.getDependency("node",n.joints[i]));return n.inverseBindMatrices!==void 0?r.push(this.getDependency("accessor",n.inverseBindMatrices)):r.push(null),Promise.all(r).then(function(i){const s=i.pop(),a=i,o=[],l=[];for(let c=0,d=a.length;c<d;c++){const m=a[c];if(m){o.push(m);const f=new it;s!==null&&f.fromArray(s.array,c*16),l.push(f)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',n.joints[c])}return new Is(o,l)})}loadAnimation(e){const r=this.json.animations[e],i=[],s=[],a=[],o=[],l=[];for(let c=0,d=r.channels.length;c<d;c++){const m=r.channels[c],f=r.samplers[m.sampler],p=m.target,T=p.node,g=r.parameters!==void 0?r.parameters[f.input]:f.input,x=r.parameters!==void 0?r.parameters[f.output]:f.output;i.push(this.getDependency("node",T)),s.push(this.getDependency("accessor",g)),a.push(this.getDependency("accessor",x)),o.push(f),l.push(p)}return Promise.all([Promise.all(i),Promise.all(s),Promise.all(a),Promise.all(o),Promise.all(l)]).then(function(c){const d=c[0],m=c[1],f=c[2],p=c[3],T=c[4],g=[];for(let w=0,I=d.length;w<I;w++){const A=d[w],R=m[w],P=f[w],D=p[w],U=T[w];if(A===void 0)continue;A.updateMatrix();let E;switch(yt[U.path]){case yt.weights:E=Os;break;case yt.rotation:E=Dn;break;case yt.position:case yt.scale:default:E=Ar;break}const C=A.name?A.name:A.uuid,j=D.interpolation!==void 0?uc[D.interpolation]:Hr,Y=[];yt[U.path]===yt.weights?A.traverse(function(K){K.morphTargetInfluences&&Y.push(K.name?K.name:K.uuid)}):Y.push(C);let X=P.array;if(P.normalized){const K=On(X.constructor),G=new Float32Array(X.length);for(let Z=0,q=X.length;Z<q;Z++)G[Z]=X[Z]*K;X=G}for(let K=0,G=Y.length;K<G;K++){const Z=new E(Y[K]+"."+yt[U.path],R.array,X,j);D.interpolation==="CUBICSPLINE"&&(Z.createInterpolant=function(we){const Oe=this instanceof Dn?cc:di;return new Oe(this.times,this.values,this.getValueSize()/3,we)},Z.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),g.push(Z)}}const x=r.name?r.name:"animation_"+e;return new Ir(x,void 0,g)})}createNodeMesh(e){const n=this.json,r=this,i=n.nodes[e];return i.mesh===void 0?null:r.getDependency("mesh",i.mesh).then(function(s){const a=r._getNodeRef(r.meshCache,i.mesh,s);return i.weights!==void 0&&a.traverse(function(o){if(o.isMesh)for(let l=0,c=i.weights.length;l<c;l++)o.morphTargetInfluences[l]=i.weights[l]}),a})}loadNode(e){const n=this.json,r=this.extensions,i=this,s=n.nodes[e],a=s.name?i.createUniqueName(s.name):"";return function(){const o=[],l=i._invokeOne(function(f){return f.createNodeMesh&&f.createNodeMesh(e)});l&&o.push(l),s.camera!==void 0&&o.push(i.getDependency("camera",s.camera).then(function(f){return i._getNodeRef(i.cameraCache,s.camera,f)})),i._invokeAll(function(f){return f.createNodeAttachment&&f.createNodeAttachment(e)}).forEach(function(f){o.push(f)});const c=[],d=s.children||[];for(let f=0,p=d.length;f<p;f++)c.push(i.getDependency("node",d[f]));const m=s.skin===void 0?Promise.resolve(null):i.getDependency("skin",s.skin);return Promise.all([Promise.all(o),Promise.all(c),m])}().then(function(o){const l=o[0],c=o[1],d=o[2];let m;if(s.isBone===!0?m=new Cs:l.length>1?m=new _n:l.length===1?m=l[0]:m=new kr,m!==l[0])for(let f=0,p=l.length;f<p;f++)m.add(l[f]);if(s.name&&(m.userData.name=s.name,m.name=a),St(m,s),s.extensions&&Qt(r,m,s),s.matrix!==void 0){const f=new it;f.fromArray(s.matrix),m.applyMatrix4(f)}else s.translation!==void 0&&m.position.fromArray(s.translation),s.rotation!==void 0&&m.quaternion.fromArray(s.rotation),s.scale!==void 0&&m.scale.fromArray(s.scale);i.associations.has(m)||i.associations.set(m,{}),i.associations.get(m).nodes=e,d!==null&&m.traverse(function(f){f.isSkinnedMesh&&f.bind(d,vc)});for(let f=0,p=c.length;f<p;f++)m.add(c[f]);return m})}loadScene(e){const n=this.extensions,r=this.json.scenes[e],i=this,s=new _n;r.name&&(s.name=i.createUniqueName(r.name)),St(s,r),r.extensions&&Qt(n,s,r);const a=r.nodes||[],o=[];for(let l=0,c=a.length;l<c;l++)o.push(i.getDependency("node",a[l]));return Promise.all(o).then(function(l){for(let d=0,m=l.length;d<m;d++)s.add(l[d]);const c=d=>{const m=new Map;for(const[f,p]of i.associations)(f instanceof en||f instanceof tt)&&m.set(f,p);return d.traverse(f=>{const p=i.associations.get(f);p!=null&&m.set(f,p)}),m};return i.associations=c(s),s})}}function xc(t,e,n){const r=e.attributes,i=new Mt;if(r.POSITION!==void 0){const o=n.json.accessors[r.POSITION],l=o.min,c=o.max;if(l!==void 0&&c!==void 0){if(i.set(new Q(l[0],l[1],l[2]),new Q(c[0],c[1],c[2])),o.normalized){const d=On(Nt[o.componentType]);i.min.multiplyScalar(d),i.max.multiplyScalar(d)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=e.targets;if(s!==void 0){const o=new Q,l=new Q;for(let c=0,d=s.length;c<d;c++){const m=s[c];if(m.POSITION!==void 0){const f=n.json.accessors[m.POSITION],p=f.min,T=f.max;if(p!==void 0&&T!==void 0){if(l.setX(Math.max(Math.abs(p[0]),Math.abs(T[0]))),l.setY(Math.max(Math.abs(p[1]),Math.abs(T[1]))),l.setZ(Math.max(Math.abs(p[2]),Math.abs(T[2]))),f.normalized){const g=On(Nt[f.componentType]);l.multiplyScalar(g)}o.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(o)}t.boundingBox=i;const a=new ks;i.getCenter(a.center),a.radius=i.min.distanceTo(i.max)/2,t.boundingSphere=a}function Er(t,e,n){const r=e.attributes,i=[];function s(a,o){return n.getDependency("accessor",a).then(function(l){t.setAttribute(o,l)})}for(const a in r){const o=Fn[a]||a.toLowerCase();o in t.attributes||i.push(s(r[a],o))}if(e.indices!==void 0&&!t.index){const a=n.getDependency("accessor",e.indices).then(function(o){t.setIndex(o)});i.push(a)}return St(t,e),xc(t,e,n),Promise.all(i).then(function(){return e.targets!==void 0?dc(t,e.targets,n):t})}function Mr(t,e){let n=t.getIndex();if(n===null){const a=[],o=t.getAttribute("position");if(o!==void 0){for(let l=0;l<o.count;l++)a.push(l);t.setIndex(a),n=t.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t}const r=n.count-2,i=[];if(e===Gr)for(let a=1;a<=r;a++)i.push(n.getX(0)),i.push(n.getX(a)),i.push(n.getX(a+1));else for(let a=0;a<r;a++)a%2===0?(i.push(n.getX(a)),i.push(n.getX(a+1)),i.push(n.getX(a+2))):(i.push(n.getX(a+2)),i.push(n.getX(a+1)),i.push(n.getX(a)));i.length/3!==r&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=t.clone();return s.setIndex(i),s}var wc=`uniform vec3 uColor;

varying vec2 vUv;

void main(){\r
    
    vec3 color=uColor;\r
    float distanceToCenter=length(vUv-.5);\r
    float alpha=.05/distanceToCenter-.1;\r
    alpha=clamp(0.,1.,alpha);\r
    if(alpha<0.01) discard;\r
    
    
    
    \r
    
    
    
    
    csm_DiffuseColor=vec4(color,alpha);\r
}`,Tc=`varying vec2 vUv;\r
void main(){\r
    vUv=uv;    \r
}`;class yc extends Hs{constructor(){super({baseMaterial:mt,transparent:!0,blending:yn,uniforms:{uColor:{value:new Fe("#4a884f")}},vertexShader:Tc,fragmentShader:wc})}}const Sc=t=>{const[e,n]=y.useState([]),r=i=>{e.every(s=>s.toString()!==i.toString())&&n(s=>[...s,i])};return y.useEffect(()=>{!t||e.length===0||t.traverse(i=>{i instanceof st&&i.material&&(i.material.transparent=!0,i.material.needsUpdate=!0,i.material.onBeforeCompile=s=>{e.forEach((a,o)=>{a(s,i.material)})})})},[t,e]),{registerShaderLogic:r}},br=t=>{const e=new Mt;return t.traverse(n=>{if(n.isMesh){const r=new Mt().setFromObject(n);e.union(r)}}),e},_c=new zr,Rr=_c.load("texture/粒子.png");function Ec({hoda:t,registerShaderLogic:e}){const[n,r]=y.useState(!1),{scene:i}=Ie(),s={value:0},a={value:NaN},o={value:NaN},l=f=>{const p=f.max.y,T=f.min.y,g=new Kn;return g.size=.25,g.color.set(4235007),g.map=Rr,g.alphaMap=Rr,g.transparent=!0,g.depthWrite=!1,g.blending=yn,g.onBeforeCompile=x=>{x.uniforms.uTime=s,x.uniforms.uInitialModelTransitionTime=a,x.uniforms.uTargetModelTransitionTime=o,x.uniforms.uHeight={value:p-T},x.uniforms.uOffset={value:T},x.vertexShader=x.vertexShader.replace("#include <common>",`

            #include <common>

            attribute vec3 aPosition;

            uniform float uTime;
            uniform float uInitialModelTransitionTime;
            uniform float uTargetModelTransitionTime;

            uniform float uHeight;
            uniform float uOffset;

        `),x.vertexShader=x.vertexShader.replace("#include <begin_vertex>",`

            #include <begin_vertex>

            float time = uTime - (transformed.y - uOffset) / (uHeight + 0.016 - 0.065);

            if (time > 0.0 && time < 1.0) {
                vec3 direction = aPosition - transformed;
                transformed = transformed + direction * time;
            } else if (time >= 1.0) {
                transformed = aPosition;
            }


        `),x.vertexShader=x.vertexShader.replace("#include <fog_vertex>",`

            #include <fog_vertex>

            vec3 positionNormalize = normalize(aPosition);

            float angle = acos(dot(positionNormalize, vec3(1.0, 0.0, 0.0)));

            float strength = sin(angle * 10.0) / 2.0;

            if (transformed.y > uInitialModelTransitionTime && transformed == position) {
                gl_PointSize = 0.0;
            } else if (aPosition.y > uTargetModelTransitionTime + strength) {
                gl_PointSize = 0.0;
            }                        

        `)},g},c=(...f)=>{let p=0;return f.forEach(T=>{p=T.length>p?T.length:p}),f.forEach((T,g)=>{let x=[];const w=Math.floor(p/T.length),I=p%T.length;for(let A=0;A<w;A++)x=x.concat(T);x=x.concat(T.slice(0,I)),f[g]=x}),f},d=(f,p=new Q(0,0,0),T=new Q(1,1,1))=>{const g=[];return f.traverse(x=>{if(x instanceof st&&x.geometry){const w=x.geometry.attributes.position.array.slice();for(let I=0;I<w.length/3;I++){const A=I*3;w[A]=w[A]*T.x,w[A+1]=w[A+1]*T.y,w[A+2]=w[A+2]*T.z,w[A]=w[A]+p.x,w[A+1]=w[A+1]+p.y,w[A+2]=w[A+2]+p.z}w.forEach(I=>{g.push(I)})}}),g};y.useEffect(()=>{if(t&&!n){const f=new Q(0,1.5,0),p=new Q(1.2,1.2,1.2),T=br(t);let g=T.clone();g.expandByVector(p),g.translate(f);const x=new Q;T.getSize(x);const w=new jn(x.x,x.z,100,100);w.rotateX(Math.PI*.5),w.translate(0,1.5,1.5),w.scale(1.2,1.2,1.2);const I=w.attributes.position.array.slice(),A=w.attributes.uv.array.slice(),R=1.2,P=2;for(let q=0;q<I.length/3;q++){const we=q*3,Oe=q*2,Ce=[A[Oe]*2-1,A[Oe+1]*2-1];I[we]=I[we],I[we+1]=I[we+1]+R*(1-Math.pow(Ce[0],P))+R*(1-Math.pow(Ce[1],P))+Math.sin(Math.random()*100)*.4,I[we+2]=I[we+2]}w.setAttribute("position",new be(new Float32Array(I),3));const D=new st(w,new mt({wireframe:!0}));g=br(D),a.value=g.min.y-.08,o.value=T.max.y+1;const[U,E]=c(d(t),d(D)),C=new Ot;C.setAttribute("position",new be(new Float32Array(E),3)),C.setAttribute("aPosition",new be(new Float32Array(U),3));const j=l(g),Y=4,X=new Zn(C,j);i.add(X);const K=new He.Tween(s).to({value:2},Y*1e3),G=new He.Tween(a).to({value:g.max.y+.08},Y*.5*1e3),Z=new He.Tween(o).to({value:T.min.y-1},Y*.75*1e3).delay(Y*.25*1e3).onComplete(()=>{r(!0),X.material.dispose(),i.remove(X)});return K&&(K.start(),G.start(),Z.start()),()=>{K&&(K.stop(),G.stop(),Z.stop())}}},[t,n]);const m=(f,p)=>{f.uniforms.uTargetModelTransitionTime=o,f.vertexShader=f.vertexShader.replace("#include <common>",`
        #include <common>
        varying vec3 vPosition;
    `),f.vertexShader=f.vertexShader.replace("#include <begin_vertex>",`
        #include <begin_vertex>
        vPosition = transformed;
    `),f.fragmentShader=f.fragmentShader.replace("#include <common>",`
        #include <common>
        varying vec3 vPosition;
        uniform float uTargetModelTransitionTime;
    `),f.fragmentShader=f.fragmentShader.replace("#include <dithering_fragment>",`
        #include <dithering_fragment>
        vec3 positionNormalize = normalize(vPosition);
        float angle = acos(dot(positionNormalize, vec3(1.0, 0.0, 0.0)));
        float strength = sin(angle * 10.0) / 2.0;

        if (vPosition.y < uTargetModelTransitionTime + strength) {
            gl_FragColor = vec4(0.0);
        } else if (vPosition.y < uTargetModelTransitionTime + strength + 0.1) {
            gl_FragColor = vec4(0.25, 0.62, 1.0, 1.0);
        }
    `)};return y.useEffect(()=>{t&&e(m)},[e]),null}function Mc(){const t=zt({files:__VITE_URL__+"/envMap/abstract-lighting-ray-room-style-01_2K_f478fdd1-243a-4cc8-b454-0f522f1afb6b.exr"}),e=Ta(1);e.camera.layers.set(1);const n=e.camera.renderTarget.texture;return Ye(()=>{e.update()}),{dynamicEnvMap:n,baseEnvMap:t}}function bc({registerShaderLogic:t}){const{dynamicEnvMap:e}=Mc(),n=(r,i)=>{i.name==="Car paint"&&(r.uniforms.uDynamicEnvMap={value:e},r.fragmentShader=r.fragmentShader.replace("#include <envmap_common_pars_fragment>",`
            #ifdef USE_ENVMAP
            
                uniform float envMapIntensity;
                uniform float flipEnvMap;
                // uniform sampler2D uBaseEnvMap;
                uniform samplerCube uDynamicEnvMap;
            
                #ifdef ENVMAP_TYPE_CUBE
                    uniform samplerCube envMap;
                #else
                    uniform sampler2D envMap;
                #endif
                
            #endif
`),r.fragmentShader=r.fragmentShader.replace("#include <envmap_physical_pars_fragment>",`
#if defined( USE_ENVMAP )

	vec3 getIBLIrradiance( const in vec3 normal ) {

		#if defined( ENVMAP_TYPE_CUBE_UV )

			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

			return PI * envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {

		#if defined( ENVMAP_TYPE_CUBE_UV )

			vec3 reflectVec = reflect( - viewDir, normal );

			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			//textureCube 只能够使用它，否则会报错1
			vec4 envMapColor2 = textureCube( uDynamicEnvMap,reflectVec);
			// 0.25 是控制环境贴图混合强度
			// 
			vec4 mixEnvMapColor=mix(envMapColor,envMapColor2,0.25);

			return mixEnvMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

#endif
`))};return y.useEffect(()=>{t(n)},[]),null}Hn({LoadingMaterial:yc});function Rc({speed:t,rotation:e,position:n}){const{carColor:r}=y.useContext(Ht),i=1;Ie();const[s,a]=y.useState(null),{scene:o,nodes:l,materials:c}=at(on,"model/汽车.glb",w=>{const I=new an;I.setDecoderPath("draco/"),w.setDRACOLoader(I)}),d=vt("texture/car_base_color_tc.png");d.format=nt,d.type=Be,d.encoding=3001,d.flipY=!1;const m=vt("texture/银色车漆.png");m.format=nt,m.type=Be,m.encoding=3001,m.flipY=!1;const f=vt("texture/蓝色车漆.png");f.format=nt,f.type=Be,f.encoding=3001,f.flipY=!1;const p=y.useRef(null);y.useEffect(()=>{const w=["polySurface481_前左轮毂","polySurface491_phong2_0","polySurface480_blinn7_0"],I=["polySurface477_后左轮毂","polySurface476_blinn7_0","polySurface539_phong2_0"],A=[],R=[];s&&(s.traverse(P=>{P.isMesh&&R.push(P)}),R.forEach((P,D)=>{(w.includes(P.name)||I.includes(P.name))&&A.push(P)}),p.current=A)},[s]),Ye((w,I)=>{if(s&&p.current){const R=I*t;p.current.forEach(P=>{P.rotation.x+=R/1*.4})}});const{registerShaderLogic:T}=Sc(s),g=y.useMemo(()=>_.jsx(bc,{registerShaderLogic:T}),[]),x=y.useMemo(()=>_.jsx(Ec,{hoda:s,registerShaderLogic:T}),[s]);return y.useEffect(()=>{if(s)switch(r){case It.OTHER:s.traverse(w=>{w.isMesh&&w.material.name=="Car paint"&&(w.material.map=d,w.material.map.colorSpace=Jt,w.material.needsUpdate=!0)});break;case It.SLIVER:s.traverse(w=>{w.isMesh&&w.material.name=="Car paint"&&(w.material.map=m,w.material.map.colorSpace=Jt,w.material.needsUpdate=!0)});break;default:s.traverse(w=>{w.isMesh&&w.material.name=="Car paint"&&(w.material.map=f,w.material.map.colorSpace=Jt,w.material.needsUpdate=!0)});break}},[s,r]),_.jsxs("group",{children:[_.jsx("primitive",{ref:a,object:o||null,scale:[i,i,i]}),x,g]})}function Ac({speed:t,position:e,rotation:n}){return _.jsx(y.Suspense,{children:_.jsx(Rc,{speed:t,rotation:n,position:e})})}function Ic({positions:t=[2,0,2,0,2,0,2,0],layers:e=1}){const n=y.useRef();return Ye((r,i)=>(n.current.position.z-=i*10)<-30&&(n.current.position.z=30)),_.jsxs(_.Fragment,{children:[_.jsx("group",{rotation:[0,.5,0],children:_.jsx("group",{ref:n,children:t.map((r,i)=>_.jsx(hr,{layers:e,form:"circle",intensity:2,rotation:[Math.PI/2,0,0],position:[r,4,i*4],scale:[3,1,1]},i))})}),_.jsx(hr,{layers:e,form:"ring",color:"red",intensity:1,scale:10,position:[-15,4,-18],target:[0,0,0]})]})}function Cc({runState:t="STOP",speed:e,setSpeed:n,isShow:r=!0}){Ie();const[i,s]=y.useState(null),[a,o]=y.useState(!1),[l,c]=y.useState(null),[d,m]=y.useState(null);y.useState(null);const[f,p]=y.useState(0),T=y.useRef({value:0});zt({files:__VITE_URL__+"/envMap/路灯.hdr"});const{scene:g,nodes:x,materials:w}=at(on,"model/街景.glb",D=>{const U=new an;U.setDecoderPath("draco/"),D.setDRACOLoader(U)}),I=vt("model/baking.png"),A=D=>{let U=new Mt;D.traverse(E=>{if(E.isMesh){const C=E.clone();C.updateMatrixWorld(!0);const j=new Mt().setFromObject(C);U.union(j)}}),p(U.max.z-U.min.z-1)};y.useEffect(()=>{i&&(A(i),new mt({map:I}))},[i]),Ye((D,U)=>{const E=-f*2;if(l&&i&&d){const C=[l,i,d];C.forEach(j=>{j.position.z-=e*U}),C.sort((j,Y)=>j.position.z-Y.position.z),C[0].position.z<E&&(C[0].position.z=C[1].position.z+f*2),C[0].position.y=[.01],C[1].position.y=[0],C[2].position.y=[.01]}});const R=()=>{i&&l&&d&&(l.position.z=f,d.position.z=-f,i.position.z=0)};y.useEffect(()=>{let D=null;const U=2;return R(),t==="RUNNING"?D=new He.Tween({value:0}).to({value:20},U*1e3).onUpdate(({value:E})=>{n(E)}):t==="STOP"&&(D=new He.Tween({value:20}).to({value:0},U*1e3).onUpdate(({value:E})=>{n(E)})),D&&D.start(),()=>{D&&D.stop()}},[t]),y.useEffect(()=>{for(let D in w){const U=w[D];U.transparent=!0}},[w]);const P=D=>{for(let U in w){const E=w[U];E.opacity=D}};return y.useEffect(()=>{let D=null;return r?(R(),o(!0),D=new He.Tween(T.current).to({value:1},5*1e3).onUpdate(({value:U})=>{P(U)})):D=new He.Tween(T.current).to({value:0},5*1e3).onUpdate(({value:U})=>{P(U)}).onComplete(()=>{o(!1)}),D&&D.start(),()=>{D&&D.stop()}},[r]),y.useEffect(()=>{},[w]),_.jsxs("group",{children:[_.jsxs("mesh",{scale:[50,50,50],"position-z":-100,children:[_.jsx("planeGeometry",{}),_.jsx("meshBasicMaterial",{color:"#000",side:ht})]}),_.jsx("primitive",{visible:a,ref:s,object:g||null}),i&&_.jsx(Bt,{visible:a,ref:c,object:i}),i&&_.jsx(Bt,{visible:a,ref:m,object:i,"position-z":-f}),r&&_.jsx(Ic,{})]})}function Dc({runState:t,speed:e,setSpeed:n,isShow:r}){return _.jsx(y.Suspense,{children:_.jsx(Cc,{runState:t,speed:e,setSpeed:n,isShow:r})})}function hi(){y.useRef(null);const t=vt(__VITE_URL__+"/texture/scuffed_cement_1k/scuffed_cement_disp_1k.png"),e=vt(__VITE_URL__+"/texture/scuffed_cement_1k/scuffed_cement_diff_1k.jpg");return _.jsxs("mesh",{rotation:[-Math.PI/2,0,0],position:[0,-.1,0],children:[_.jsx("planeGeometry",{args:[50,50]}),_.jsx(Aa,{blur:[600,200],resolution:1024,mixBlur:1,mixStrength:300,roughness:1,depthScale:1.2,minDepthThreshold:.4,maxDepthThreshold:1.4,color:"#111111",metalness:.5,displacementMap:t,map:e})]})}function Uc({isShow:t=!0}){const e=y.useRef({value:1}),n=y.useRef(null);y.useState(new Q(1,1,1));const[r,i]=y.useState(),{scene:s,nodes:a}=at(on,"model/字体.glb",c=>{const d=new an;d.setDecoderPath("draco/"),c.setDRACOLoader(d)}),o=vt("texture/noiseTexture.png");y.useEffect(()=>{if(!r||!n)return;const c=new Mt;c.setFromObject(r);const d=new Q;c.getSize(d);const m=new Gs(c,"#ffffff");s.add(m);const f=c.max.z-c.min.z,p=c.max.y-c.min.y,T=r.geometry.attributes.position.count,g=r.geometry.attributes.position.array.slice(),x=[];for(let w=0;w<T;w++){const I=w*3,A=w*2;x[A]=(g[I+2]-c.min.z)/f,x[A+1]=(g[I+1]-c.min.y)/p*1}r.geometry.setAttribute("aUv",new be(new Float32Array(x),2))},[r]);const l=c=>{c.uniforms.uProgress=e.current,c.uniforms.uPerlinTexture={value:o},c.vertexShader=c.vertexShader.replace("#include <common>",`

                #include <common>

                uniform float uProgress;
                varying vec2 vUv;
                attribute vec2 aUv;

            `),c.vertexShader=c.vertexShader.replace("#include <begin_vertex>",`

                #include <begin_vertex>
                vUv=aUv;

            `),c.fragmentShader=c.fragmentShader.replace("#include <common>",`

                 varying vec2 vUv;
                 uniform float uProgress;
                 uniform sampler2D uPerlinTexture;
                #include <common>

            `),c.fragmentShader=c.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );",`
                
                vec4 diffuseColor = vec4( diffuse, opacity );
            `),c.fragmentShader=c.fragmentShader.replace("vec3 totalEmissiveRadiance = emissive;",`
        vec3 totalEmissiveRadiance = emissive;
        vec2 fmcUv=clamp(vUv,0.0,1.0);
        float fmcDuration=0.4;
        float noise=texture(uPerlinTexture,vec2(fmcUv.x,fmcUv.x)).r;
        float fmcDelay=(1.0-fmcDuration)*noise;
        float fmcEnd=fmcDuration+fmcDelay;
        float fmcProgress=smoothstep(fmcDelay,fmcEnd ,uProgress );

        fmcProgress=fmcProgress*1.02-0.01;
        float strength=1.0-step(fmcUv.y,fmcProgress);
        if(strength<0.01) discard;
            `)};return y.useEffect(()=>{let c=null;return t?c=new He.Tween(e.current).to({value:0},5*1e3):c=new He.Tween(e.current).to({value:1},5*1e3),c&&c.start(),()=>{c&&c.stop()}},[t]),_.jsx("group",{position:[4,2,1],rotation:[0,-Math.PI,0],scale:[1.5,1.5,1.5],dispose:null,children:_.jsx("mesh",{scale:[.8,.8,.8],ref:i,geometry:a.文本.geometry,children:_.jsx("meshPhysicalMaterial",{color:"#1e90ff",toneMapped:!1,transparent:!0,emissive:"#1e90ff",emissiveIntensity:1.3,onBeforeCompile:l})})})}function Lc(){const t=y.useMemo(()=>_.jsx(hi,{}),[]);return _.jsx(_.Fragment,{children:_.jsxs(y.Suspense,{children:[t," "]})})}function Pc(){const{nodes:t,materials:e}=at(on,"model/流.glb",n=>{const r=new an;r.setDecoderPath("draco/"),n.setDRACOLoader(r)});return Ye((n,r)=>{if(e&&e.空气流材质){const{map:i}=e.空气流材质;i.offset.y+=r}}),_.jsx(y.Suspense,{children:_.jsx("group",{children:_.jsx("mesh",{geometry:t.流.geometry,material:e.空气流材质})})})}function Nc(){const{scene:t}=Ie(),e=vt("texture/circle_05.png"),n=vt("texture/noiseTexture.png"),r=8,i=y.useRef({value:0});y.useRef(null);const s=()=>{const a=new js(0,0,r,r,0,2*Math.PI,!1,0);let o=[],l=719;for(let g=0;g<5;g++)o=[...o,...a.getPoints(l)],a.xRadius+=.2,a.yRadius+=.2;const c=o.map((g,x)=>x),d=new Ot().setFromPoints(o);d.rotateX(Math.PI*.5),d.translate(0,.1,2.5);let m=d.getAttribute("position").array.slice();for(let g=0;g<m.length/3;g++){const x=g*3;m[x+1]+=Math.floor(g/720)*.15}const f=[];for(let g=0;g<m.length/3;g++){const x=g*3;f[x]=m[(g%720+720*4)*3]-m[g%720*3],f[x+1]=m[(g%720+720*4)*3+1]-m[g%720*3+1],f[x+2]=m[(g%720+720*4)*3+2]-m[g%720*3+2]}d.setAttribute("aNormal",new be(new Float32Array(f),3)),d.setAttribute("aIndex",new be(new Float32Array(c),1)),d.setAttribute("position",new be(new Float32Array(m),3));const p=new Kn({color:4235007,size:.5,map:e,alphaMap:e,transparent:!0,depthWrite:!1,blending:yn});p.onBeforeCompile=g=>{g.uniforms.uTime=i.current,g.uniforms.uPerlinTexture={value:n},g.uniforms.baseColor1={value:new Fe(9498256)},g.uniforms.baseColor2={value:new Fe(16753920)},g.uniforms.baseColor3={value:new Fe(10170623)},g.vertexShader=g.vertexShader.replace("#include <common>",`

            #include <common>
            attribute float aIndex;
            attribute vec3 aNormal;
            uniform float uTime;
            uniform sampler2D uPerlinTexture;
            varying float vIndex;
            varying float vSelfIndex;
            varying float vCircleNum;
            
            float getStrength(float aIndex,float uTime,vec3 aNormal){
                    float selfIndex = mod(aIndex, 720.0);      // 计算每个点在圆环上的位置索引
                    float circleNum = (aIndex - selfIndex) / 720.0; // 计算点所在的“圈号”，但此值目前未使用
                
                    vec3 pDir = normalize(aNormal);            // 获取法线方向，后续将用其调整偏移方向
                    float waveWidth = 90.0;                    // 波动效果的宽度
                    float totalLength = 720.0;                 // 圆的总长度（720度）
                    float modUtime = mod(uTime * 50.0, 720.0); // 时间的循环，乘以 30.0 是加速效果
                    float dw = waveWidth*0.5;              // 平滑过渡的宽度，控制波动的范围
                
                    // 计算波动强度
                    // 对首尾连接部分（0 和 720）进行平滑过渡处理
                    float smoothStart = smoothstep(modUtime , modUtime+dw, selfIndex);
                    float smoothEnd = 1.0-smoothstep(modUtime+waveWidth - dw,modUtime+waveWidth, selfIndex);
                    
                    // 创建平滑连接：确保波动在 [720 - dw, 720 + waveWidth] 和 [0, dw] 区间内平滑过渡
                    float strength = min(smoothStart,smoothEnd);
                    
                    
                    float isOver=step(720.0,modUtime+waveWidth);
                    float over=(modUtime+waveWidth-720.0);
                    float isOverStep1=(1.0-step(dw,over))*isOver;
                    float isOverStep2=step(dw,over);
                    
                    float overStep1Left=min(smoothstep(modUtime,modUtime+dw,selfIndex),(1.0-smoothstep(modUtime+waveWidth - dw,modUtime+waveWidth, selfIndex)));
                    float overStep1Right=1.0-smoothstep(modUtime+waveWidth - dw,modUtime+waveWidth, selfIndex+720.0);
                    float overStep1=max(overStep1Left,overStep1Right);
                    
                    float overStep2Left=smoothstep(modUtime,modUtime+dw,selfIndex);
                    float overStep2Right=min(smoothstep(modUtime,modUtime+dw,selfIndex+720.0),(1.0-smoothstep(modUtime+waveWidth - dw,modUtime+waveWidth, selfIndex+720.0)));
                    float overStep2=max(overStep2Left,overStep2Right);
                    
                    float os=isOverStep1*overStep1+overStep2*isOverStep2;


 
                    
                    
     
                    strength=(1.0-isOver)*strength+isOver*os;
                    return strength;
            }
        `),g.vertexShader=g.vertexShader.replace("#include <begin_vertex>",`

                   #include <begin_vertex>
                       float selfIndex = mod(aIndex, 720.0);
                     float circleNum = (aIndex - selfIndex) / 720.0;
                    vec3 pDir = normalize(aNormal);  

                
                    float noise=texture(uPerlinTexture,vec2((selfIndex/720.0),mod(uTime*0.1,1.0))).r;
                
               
                    float strength=getStrength(aIndex,uTime,aNormal);
                        strength+=getStrength(aIndex,uTime+10.0+noise,aNormal);
                        strength+=getStrength(aIndex,uTime+20.0+noise,aNormal);
                        strength+=getStrength(aIndex,uTime+30.0+noise,aNormal);
                        strength+=getStrength(aIndex,uTime+40.0+noise,aNormal);                        
                        strength+=getStrength(aIndex,uTime+50.0+noise,aNormal); 
                        strength+=getStrength(aIndex,uTime+60.0+noise,aNormal); 
                        strength+=getStrength(aIndex,uTime+70.0+noise,aNormal);  
                        strength+=getStrength(aIndex,uTime+80.0+noise,aNormal);
                        strength+=getStrength(aIndex,uTime+90.0+noise,aNormal);                         


                                     // 偏移的强度因子，当前没有动态变化
                
                    // 基于法线方向和波动强度偏移点的 x 和 z 坐标
                    transformed.x += pDir.x * strength*0.5;
                    transformed.z += pDir.z* strength*0.5;
                     transformed.y += strength*circleNum*noise*0.6 ;
                    //transformed.y +=strength * circleNum*0.08;
                    
                
                    vIndex = aIndex;                          // 将索引传递给片段着色器（或者用于调试）
            `),g.fragmentShader=g.fragmentShader.replace("#include <common>",`

                 varying float vIndex;
                 
                  uniform float uTime;
                  uniform vec3 baseColor1;
                  uniform sampler2D uPerlinTexture;
                  uniform vec3 baseColor2;
                  uniform vec3 baseColor3;
                #include <common>
            `),g.fragmentShader=g.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );",`
                vec3 whiteColor = vec3( 1.0,1.0,1.0);
                float selfIndex=mod(vIndex,720.0);
                float circleNum=(vIndex - selfIndex)/720.0;
                //float nuo=mod(uTime*0.2,1.0);
                vec3  baseColor=mix(baseColor1,baseColor2,mod(uTime*0.1,1.0));
                 baseColor=mix(baseColor,baseColor3,mod(uTime*0.2,1.0));
                vec3 finalColor=mix(baseColor,diffuse,circleNum/5.0);
                finalColor*=1.0;
                vec4 diffuseColor = vec4( finalColor, opacity );
            `)};const T=new Zn(d,p);return t.add(T),T};return y.useEffect(()=>{const a=s();return()=>{t.remove(a)}},[]),Ye((a,o)=>{i.current.value+=o}),_.jsx(_.Fragment,{})}function Bc(){const[t,e]=y.useState(null),[n,r]=y.useState(0),i=9,[s,a]=y.useState(null),[o,l]=y.useState(null),[c,d]=y.useState(null),m=y.useRef(null),f=y.useRef({value:0}),{scene:p,nodes:T,materials:g}=at(on,"model/low_poly_cars_pack.glb",R=>{const P=new an;P.setDecoderPath("draco/"),R.setDRACOLoader(P)}),x=R=>{let P=new Mt;R.traverse(D=>{if(D.isMesh){const U=D.clone();U.updateMatrixWorld(!0);const E=new Mt().setFromObject(U);P.union(E)}}),r(P.max.z-P.min.z-1)},w=R=>{const P=new Q;R.traverse(D=>{if(D.isMesh&&D.name.includes("car")){D.updateMatrixWorld(!0);const U=D.getWorldPosition(P);new me(U.x,U.z).length()<=i?m.current&&(D.material=m.current):D.material=g.车白模}})},I=()=>{o&&c&&s&&(s.position.z=0,o.position.z=n,c.position.z=-n)};y.useEffect(()=>{s&&x(s)},[s]),y.useEffect(()=>{if(g&&!m.current){const R=g.车白模;m.current=R.clone()}},[g]),y.useEffect(()=>{m.current&&(m.current.onBeforeCompile=R=>{R.uniforms.uTime=f.current,R.vertexShader=R.vertexShader.replace("#include <common>",`

                    #include <common>
                    varying vec3 vPosition;
                 `),R.vertexShader=R.vertexShader.replace("#include <begin_vertex>",`
               #include <begin_vertex>                    
                vPosition = transformed; 
        `),R.fragmentShader=R.fragmentShader.replace("#include <common>",`
     
                    uniform float uTime;            
                    varying vec3 vPosition;
                    #include <common>
                `),R.fragmentShader=R.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );",`
                    float progress=clamp(0.0,1.0,vPosition.y/3.2);
                    float dw=0.05;
                    float start=uTime*0.6;
                    start=mod(start,1.0);
                    float end=start+0.1;
                    float strength=min(smoothstep(start,start+dw,progress),(1.0-smoothstep(end-dw,end,progress)));
                    
                    vec3 mixColor=mix(diffuse,vec3(0.6,0.6,0.6),strength);
                    vec4 diffuseColor =vec4(mixColor, opacity );;
        `)})},[m.current]);const A=R=>{const P={position:[0,0,0],radius:i*.99,size:i,color:4235007,opacity:.9,speed:110,followWidth:90};R.uniforms.uTime=f.current,R.uniforms.uSpeed={value:P.speed},R.uniforms.uRadius={value:P.radius},R.uniforms.uFollowWidth={value:P.followWidth},R.uniforms.ncolor={value:new Fe(P.color)},R.vertexShader=R.vertexShader.replace("#include <common>",`

        #include <common>
        varying vec3 vPosition;
        `),R.vertexShader=R.vertexShader.replace("#include <begin_vertex>",`
               #include <begin_vertex>                    
                vPosition = position; 
        `),R.fragmentShader=R.fragmentShader.replace("#include <common>",`
            uniform float uRadius;     
            uniform float uTime;            
            uniform float uSpeed; 
            uniform float uFollowWidth; 
            varying vec3 vPosition;
            uniform vec3 ncolor;
            float calcAngle(vec3 oFrag){
                float fragAngle;
                const vec3 ox = vec3(1,0,0);
                float dianji = oFrag.x * ox.x + oFrag.z*ox.z;
                float oFrag_length = length(oFrag); // length是内置函数
                float ox_length = length(ox); // length是内置函数
                float yuxian = dianji / (oFrag_length * ox_length);
                fragAngle = acos(yuxian);
                fragAngle = degrees(fragAngle);
                if(oFrag.z > 0.0) {
                fragAngle = -fragAngle + 360.0;
                }
                float scanAngle = uTime * uSpeed - floor(uTime * uSpeed / 360.0) * 360.0;
                float angle = scanAngle - fragAngle;
                if(angle < 0.0){
                angle = angle + 360.0;
                }
                return angle;
            }
            #include <common>
        `),R.fragmentShader=R.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );",`
            vec4 finalColor=vec4(0.0,0.0,0.0,1.0);
        if(length(vPosition) == 0.0 || length(vPosition) > uRadius){
			finalColor = vec4( ncolor, 1.0);
		} else {
			float angle = calcAngle(vPosition);
			if(angle < uFollowWidth){
				// 尾焰区域
				float opacity1 =  1.0 - angle / uFollowWidth; 
				finalColor = vec4( ncolor, 1.0 * opacity1 );  
			} else {
				// 其他位置的像素均为透明
				finalColor = vec4( ncolor, 0.0 ); 
			}
		}
            float angle = calcAngle(vPosition);
            //vec4 diffuseColor =vec4((angle/360.0),0.0,0.0,1.0);
            vec4 diffuseColor =finalColor;
        `)};return Ye((R,P)=>{t&&(f.current.value+=P)}),y.useEffect(()=>{I()},[s,o,c]),Ye((R,P)=>{const D=-n*2;if(o&&c&&s){w(o),w(s),w(c);const E=[o,s,c];E.forEach(C=>{C.position.z-=10*P}),E.sort((C,j)=>C.position.z-j.position.z),E[0].position.z<D&&(E[0].position.z=E[1].position.z+n*2),E[0].position.y=[.01],E[1].position.y=[0],E[2].position.y=[.01]}}),_.jsxs(_.Fragment,{children:[_.jsxs("group",{children:[_.jsx("primitive",{ref:a,castShadow:!1,receiveShadow:!1,object:p||null}),s&&_.jsx(Bt,{ref:l,object:s,deep:!0,"position-z":n,castShadow:!1,receiveShadow:!1,inject:R=>{}}),s&&_.jsx(Bt,{ref:d,object:s,deep:!0,castShadow:!1,receiveShadow:!1,"position-z":-n,inject:R=>{}})]}),_.jsxs("mesh",{ref:e,"position-y":.2,"rotation-x":Math.PI*.5,"rotation-z":Math.PI*.5,children:[_.jsx("circleGeometry",{args:[i,1e3]}),_.jsx("meshBasicMaterial",{transparent:!0,blending:yn,side:ht,depthTest:!0,depthWrite:!1,onBeforeCompile:A})]})]})}function Fc(){const{techType:t}=y.useContext(Ht),e=y.useMemo(()=>_.jsx(hi,{}),[]);return _.jsxs(_.Fragment,{children:[t===Me.FLOW&&_.jsx(Pc,{}),t!==Me.LD&&e,t===Me.MEDEA&&_.jsx(Nc,{}),t===Me.LD&&_.jsx(Bc,{})]})}function Oc(){const{sceneType:t,techType:e}=y.useContext(Ht),[n,r]=y.useState(0),[i,s]=y.useState("RUNNING");return y.useEffect(()=>{let a=null;if(t===le.SHOWROOM)a=new He.Tween({value:20}).to({value:0},2*1e3).onUpdate(({value:o})=>{r(o)}),s("STOP");else if(t===le.TECH)switch(e){case Me.MEDEA:n===20&&(a=new He.Tween({value:20}).to({value:0},2*1e3).onUpdate(({value:o})=>{r(o)}),s("STOP"));break;case Me.FLOW:case Me.LD:n===0&&(s("RUNNING"),a=new He.Tween({value:0}).to({value:20},2*1e3).onUpdate(({value:o})=>{r(o)}));break}else t===le.ROAD&&(s("RUNNING"),a=new He.Tween({value:0}).to({value:20},2*1e3).onUpdate(({value:o})=>{r(o)}));return a&&a.start(),()=>{a&&a.stop()}},[t,e]),_.jsxs(_.Fragment,{children:[_.jsx(Ac,{speed:n}),_.jsx(Uc,{isShow:t===le.SHOWROOM}),t===le.SHOWROOM&&_.jsx(Lc,{}),_.jsx(Dc,{runState:i,speed:n,setSpeed:a=>{r(a)},isShow:t===le.ROAD}),t===le.TECH&&_.jsx(Fc,{})]})}function kc(){return _.jsxs("div",{className:"maxwell-car-three",children:[_.jsxs(Zs,{gl:{logarithmicDepthBuffer:!0,antialias:!0,outputColorSpace:Jt},dpr:[1,1.5],camera:{position:[0,0,15],fov:25},children:[_.jsx("color",{attach:"background",args:["#000000"]}),_.jsx("hemisphereLight",{intensity:.8}),_.jsx(Wa,{}),_.jsx(Hl,{}),_.jsx(Oc,{})]}),_.jsx(Ea,{}),_.jsx(Xs,{})]})}function zc({handleSceneChange:t,handleColorChange:e,handleTechTypeChange:n}){const{sceneType:r,carColor:i,techType:s}=y.useContext(Ht),a=c=>{if(c==le.SHOWROOM)return 3.5;if(c==le.ROAD)return 17.5;if(c==le.TECH)return 31.5},o=c=>c*8+2,l=()=>{n(Me.MEDEA)};return _.jsx(_.Fragment,{children:_.jsxs("div",{className:"maxwell-home",children:[_.jsxs("div",{className:"maxwell-home-header maxwell-home-fixed",children:[r==le.SHOWROOM&&_.jsxs(_.Fragment,{children:[_.jsx("h1",{className:"blue mb-10 brand",children:"Luxvire"}),_.jsx("p",{className:"wihte mb-5",children:"Beyond Luxury, Beyond Speed"}),_.jsx("p",{className:"wihte mb-5",children:"麦克斯韦全新跑车，专为极致性能与奢华体验而生"})]}),r==le.ROAD&&_.jsxs(_.Fragment,{children:[_.jsx("h2",{className:"blue mb-10",children:"Beyond Luxury, Beyond Speed"}),_.jsx("p",{className:"wihte mb-5",children:"搭载顶级动力系统，提供非凡加速与优雅流畅的驾驶体验"}),_.jsx("p",{className:"wihte mb-5",children:"内饰结合细腻材质与智能科技，带来无与伦比的舒适与控制感"}),_.jsx("p",{className:"wihte mb-5",children:"这不仅是一辆跑车，更是奢华与速度的完美体现"})]}),r==le.TECH&&s==Me.MEDEA&&_.jsxs(_.Fragment,{children:[_.jsx("h2",{className:"blue mb-10",children:"沉浸式车载娱乐系统"}),_.jsx("p",{className:"wihte mb-5",children:"杜比环绕声，让每一个音符触动心弦"}),_.jsx("p",{className:"wihte mb-5",children:"智能在线连接，畅享音乐、电影与导航的无缝融合"}),_.jsx("p",{className:"wihte mb-5"})]}),r==le.TECH&&s==Me.FLOW&&_.jsxs(_.Fragment,{children:[_.jsx("h2",{className:"blue mb-10",children:"突破风的桎梏，尽享速度的激情"}),_.jsx("p",{className:"wihte mb-5",children:"流线型车身，宛如风中舞者，将阻力降至最低"}),_.jsx("p",{className:"wihte mb-5",children:"卓越空气动力性能，赋予您无与伦比的加速体验"})]}),r==le.TECH&&s==Me.LD&&_.jsxs(_.Fragment,{children:[_.jsx("h2",{className:"blue mb-10",children:"智感未来，驾驭无忧"}),_.jsx("p",{className:"wihte mb-5",children:"智能雷达系统，全天候感知周围环境，精准扫描、实时反馈，助您从容应对复杂路况"}),_.jsx("p",{className:"wihte mb-5",children:"先进智驾系统，融合AI科技，智能规划行车路线，自动辅助驾驶，让每一次出行更安全、更高效。"})]})]}),_.jsxs("div",{className:"maxwell-home-right maxwell-home-fixed",children:[_.jsxs("div",{className:"item",onClick:()=>{l(),t(le.SHOWROOM)},children:[_.jsx("div",{className:r==le.SHOWROOM?"item-text active":"item-text",children:"造型"}),_.jsx("div",{className:"item-Line"})]}),_.jsxs("div",{className:"item",onClick:()=>{l(),t(le.ROAD)},children:[_.jsx("div",{className:r==le.ROAD?"item-text active":"item-text",children:"行驶"}),_.jsx("div",{className:"item-Line"})]}),_.jsxs("div",{className:"item",onClick:()=>{l(),t(le.TECH)},children:[_.jsx("div",{className:r===le.TECH?"item-text active":"item-text",children:"科技"}),_.jsx("div",{className:"item-Line"})]}),_.jsx("div",{className:"line",style:{top:`${a(r)}vmin`}})]}),_.jsxs("div",{className:"maxwell-home-bottom maxwell-home-fixed",children:[(r==le.SHOWROOM||r==le.ROAD)&&_.jsxs("div",{className:"bar-content",children:[_.jsxs("div",{className:"bar",onClick:()=>{e(It.BLUE)},children:[_.jsx("img",{src:__VITE_URL__+"/texture/蓝色车漆预览.png",className:"active"}),_.jsx("div",{className:"bar-line"})]}),_.jsxs("div",{className:"bar",onClick:()=>{e(It.SLIVER)},children:[_.jsx("img",{src:__VITE_URL__+"/img/银色.png",className:"active"}),_.jsx("div",{className:"bar-line"})]}),_.jsxs("div",{className:"bar",onClick:()=>{e(It.OTHER)},children:[_.jsx("img",{src:__VITE_URL__+"/texture/123374379_p0_master1200.jpg",className:"active"}),_.jsx("div",{className:"bar-line"})]}),_.jsx("div",{className:"line",style:{left:`${o(i)}vmin`}})]}),r===le.TECH&&_.jsxs("div",{className:"bar-content",children:[_.jsxs("div",{className:"bar",title:"影音娱乐",onClick:()=>{n(Me.MEDEA)},children:[_.jsx("img",{src:__VITE_URL__+"/texture/多媒体 (1).png",className:"active"}),_.jsx("div",{className:"bar-line"})]}),_.jsx("div",{className:"line",style:{left:`${o(s)}vmin`}}),_.jsxs("div",{className:"bar",title:"空气动力",onClick:()=>{n(Me.FLOW)},children:[_.jsx("img",{src:__VITE_URL__+"/texture/wind-flow-2--wind-flow-weather.png",className:"active"}),_.jsx("div",{className:"bar-line"})]}),_.jsxs("div",{className:"bar",title:"智驾辅助",onClick:()=>{n(Me.LD)},children:[_.jsx("img",{src:__VITE_URL__+"/texture/雷达.png",className:"active"}),_.jsx("div",{className:"bar-line"})]})]})]})]})})}function Wc(){const[t,e]=y.useState(le.SHOWROOM),[n,r]=y.useState(It.BLUE),[i,s]=y.useState(Me.MEDEA);return _.jsx(_.Fragment,{children:_.jsx("div",{className:"maxwell-car",children:_.jsxs(Ht.Provider,{value:{sceneType:t,carColor:n,techType:i,setSceneType:e,setCarColor:r,setTechType:s},children:[_.jsx(zc,{handleSceneChange:a=>{e(a)},handleColorChange:a=>{r(a)},handleTechTypeChange:a=>{s(a)}}),_.jsx(kc,{})]})})})}export{Wc as default};
//# sourceMappingURL=maxwell-car-CAZAL5G1.js.map
